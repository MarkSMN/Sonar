<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Sonar - Tangent Circle Solver (EXPERIMENTAL)</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Courier New', Courier, monospace;
            overflow: hidden;
            display: flex;
            height: 100vh;
            background: #000000;
        }
        #canvas-container {
            flex: 1;
            background: #ffffff;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }
        #canvas-wrapper {
            position: relative;
            display: inline-block;
        }
        #canvas {
            background: #ffffff;
            display: block;
        }
        #thumbnail-gallery {
            position: absolute;
            top: 765px;
            left: 0;
            display: flex;
            align-items: flex-start;
            gap: 10px;
            z-index: 1;
            pointer-events: none;
        }
        .thumbnail-item {
            flex-shrink: 0;
            text-align: center;
            pointer-events: auto;
        }
        .thumbnail-item:nth-child(1) {
            order: 1;
        }
        .thumbnail-item:nth-child(2) {
            order: 4;
        }
        .thumbnail-item:nth-child(3) {
            order: 2;
        }
        .thumbnail-item:nth-child(4) {
            order: 3;
        }
        .thumbnail-image {
            width: 200px;
            height: 200px;
            object-fit: cover;
            border: 2px solid #cccccc;
            display: block;
            background: white;
        }
        .thumbnail-label {
            font-size: 10px;
            color: #888888;
            margin-top: 4px;
            font-family: 'Courier New', monospace;
        }
        #sidebar {
            width: 300px;
            background: #1a1a1a;
            color: #cccccc;
            display: flex;
            flex-direction: column;
            padding: 20px;
            overflow-y: auto;
        }
        #sidebar h1 {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 20px;
            letter-spacing: 1px;
            color: #ffffff;
        }
        .section {
            margin-bottom: 20px;
        }
        .section-title {
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1.2px;
            margin-bottom: 10px;
            color: #888888;
        }
        .info-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 6px;
            font-size: 12px;
        }
        .info-label {
            color: #888888;
        }
        .info-value {
            color: #cccccc;
            font-weight: 500;
            font-family: monospace;
        }
        button {
            background: #2a2a2a;
            color: #cccccc;
            border: none;
            border-radius: 6px;
            padding: 8px 12px;
            margin-bottom: 6px;
            cursor: pointer;
            font-family: 'Courier New', Courier, monospace;
            font-size: 12px;
            font-weight: 500;
            transition: background 0.2s;
            width: 100%;
            text-align: left;
        }
        button:hover {
            background: #333333;
            color: #ffffff;
        }
        button:active {
            background: #3a3a3a;
        }
        label {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            font-size: 12px;
            font-weight: 400;
            cursor: pointer;
            color: #cccccc;
        }
        input[type="checkbox"] {
            margin-right: 8px;
            width: 16px;
            height: 16px;
            cursor: pointer;
            accent-color: #666666;
        }
    </style>
</head>
<body>
    <div id="canvas-container">
        <div id="canvas-wrapper">
            <canvas id="canvas" width="1200" height="900"></canvas>
        </div>
        <div id="thumbnail-gallery">
            <!-- Thumbnails will be added here -->
        </div>
    </div>

    <div id="sidebar">
        <h1>SONAR <span style="color: #00ff00; font-size: 10px;">EXPERIMENTAL</span></h1>

        <div class="section">
            <div class="section-title">Instructions</div>
            <div style="font-size: 12px; line-height: 1.6; color: #999999;">
                <p style="margin-bottom: 8px;">Drag anchors to adjust triangulation</p>
                <p style="margin-bottom: 8px;">A: Add random tangent lens</p>
                <p style="margin-bottom: 8px;">Click lens + D: Delete lens</p>
                <p style="margin-bottom: 8px;">Click lens + K: Remove legs</p>
                <p style="margin-bottom: 8px;">Click lens + R: Cycle leg type</p>
                <p style="margin-bottom: 8px;">Space: New composition</p>
                <p style="margin-bottom: 8px;">N: Regenerate lenses</p>
                <p style="margin-bottom: 8px;">M: Regenerate legs</p>
                <p style="margin-bottom: 8px;">Z: Cycle strategy</p>
                <p style="margin-bottom: 8px;">P: Cycle color palette</p>
                <p style="margin-bottom: 8px;">L: Toggle legs</p>
                <p>C: Toggle colors</p>
            </div>
        </div>

        <div class="section">
            <div class="section-title">Export</div>
            <button onclick="exportAllFiles()" style="background: #3a3a3a; color: #00ff00; font-weight: 600;">Export All Files</button>
            <button onclick="exportJSON()">Save JSON</button>
            <button onclick="exportPNG()">Save PNG</button>
            <button onclick="exportLensSVG()">Save Lens SVG</button>
        </div>

        <div class="section">
            <div class="section-title">Display</div>
            <label>
                <input type="checkbox" id="showLegs" checked onchange="draw()">
                Show Legs
            </label>
            <label>
                <input type="checkbox" id="showColors" checked onchange="draw()">
                Colored Lenses
            </label>
            <label>
                <input type="checkbox" id="stealthMode" onchange="draw()">
                Stealth Mode
            </label>
        </div>

        <div class="section">
            <div class="section-title">Composition Info</div>
            <div class="info-row">
                <span class="info-label">Strategy</span>
                <span class="info-value" id="strategy-name">Dense Packing</span>
            </div>
            <div class="info-row">
                <span class="info-label">Rings</span>
                <span class="info-value" id="circle-count">0</span>
            </div>
            <div class="info-row">
                <span class="info-label">Attempts</span>
                <span class="info-value" id="attempts">0</span>
            </div>
            <div class="info-row">
                <span class="info-label">Palette</span>
                <span class="info-value" id="palette-name">Full Range</span>
            </div>
            <div class="info-row">
                <span class="info-label">Seed</span>
                <span class="info-value" id="seed-display">-</span>
            </div>
        </div>

        <div class="section">
            <div class="section-title">Specifications</div>
            <div class="info-row">
                <span class="info-label">Leg Thickness</span>
                <span class="info-value">1.2mm</span>
            </div>
            <div class="info-row">
                <span class="info-label">Lens Thickness</span>
                <span class="info-value">2.4mm</span>
            </div>
            <div class="info-row">
                <span class="info-label">Anchor Diameter</span>
                <span class="info-value">6.36mm</span>
            </div>
            <div class="info-row">
                <span class="info-label">Max Leg Count</span>
                <span class="info-value">5</span>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // Real-world dimensions in mm
        const LEG_THICKNESS = 1.2;      // mm
        const LENS_THICKNESS = 2.4;     // mm (ring frame)
        const ANCHOR_DIAMETER = 6.36;   // mm (circle diameter)
        const ANCHOR_HOLE_SIZE = 2.8;   // mm (square hole)

        // Scale for display
        const SCALE = 3.5;
        const CENTER_X = canvas.width / 2;
        const CENTER_Y = canvas.height / 2;
        const BOUNDARY = 152;           // mm (work area) - 6" x 6" = 152.4mm

        // User-adjustable parameters
        let MAX_LENS_COUNT = 12;
        let MAX_LEG_COUNT = 5;

        let anchors = [];
        let rings = [];
        let attempts = 0;
        let currentSeed = Date.now();
        let lensSeed = Date.now();
        let legSeed = Date.now();

        // Strategy system
        let currentStrategy = 0;
        const STRATEGIES = [
            {
                name: 'Dense Packing',
                description: 'Pack as many lenses as fit',
                minLenses: 8,
                maxLenses: 12,
                radiusMode: 'weighted_random'
            },
            {
                name: 'Sparse Giant',
                description: '2-4 huge lenses only',
                minLenses: 2,
                maxLenses: 4,
                radiusMode: 'large_only'
            },
            {
                name: 'Minimalist',
                description: '1-2 massive lenses',
                minLenses: 1,
                maxLenses: 2,
                radiusMode: 'maximal'
            },
            {
                name: 'Top-Heavy',
                description: 'Cluster in upper half, long legs',
                minLenses: 4,
                maxLenses: 7,
                radiusMode: 'weighted_random',
                constraint: 'upper_half'
            },
            {
                name: 'Bottom-Heavy',
                description: 'Cluster in lower half, short legs',
                minLenses: 4,
                maxLenses: 7,
                radiusMode: 'weighted_random',
                constraint: 'lower_half'
            },
            {
                name: 'Ring Formation',
                description: 'Hollow center, lenses around edges',
                minLenses: 5,
                maxLenses: 9,
                radiusMode: 'weighted_random',
                constraint: 'ring'
            },
            {
                name: 'Micro Cluster',
                description: 'Many tiny lenses',
                minLenses: 15,
                maxLenses: 25,
                radiusMode: 'small_only'
            },
            {
                name: 'Twins',
                description: 'Only 2-3 sizes repeated',
                minLenses: 5,
                maxLenses: 9,
                radiusMode: 'twins'
            },
            {
                name: 'Apollonian',
                description: '3-anchor tangent base + nested fill',
                minLenses: 1,
                maxLenses: 8,
                radiusMode: 'apollonian'
            },
            {
                name: 'Halo',
                description: 'One giant lens + swarm of tiny lenses',
                minLenses: 12,
                maxLenses: 20,
                radiusMode: 'halo'
            }
        ];

        // Thumbnail gallery (max 4)
        let thumbnails = [];

        // Dragging state
        let draggedAnchor = null;
        let isDragging = false;

        // Selected lens for leg editing
        let selectedLens = null;

        // Color palettes for lenses
        const COLOR_PALETTES = {
            'full_range': {
                name: 'Full Range',
                colors: ['#F4E8A0', '#E8C5A0', '#E8C4D5', '#A0B0E8', '#C4A0E8', '#999999']
            },
            'light_triad': {
                name: 'Light Value Triad',
                colors: ['#F4E8A0', '#E8C5A0', '#E8C4D5']
            },
            'dark_triad': {
                name: 'Dark Value Triad',
                colors: ['#A0B0E8', '#C4A0E8', '#999999']
            },
            'yellow_blue': {
                name: 'Yellow + Blue (Green Mix)',
                colors: ['#F4E8A0', '#A0B0E8']
            },
            'unique_triad': {
                name: 'Unique Triad',
                colors: ['#F4E8A0', '#C4A0E8', '#999999']
            },
            'yellow_mono': {
                name: 'Monochrome Yellow',
                colors: ['#F4E8A0']
            },
            'orange_mono': {
                name: 'Monochrome Orange',
                colors: ['#E8C5A0']
            },
            'pink_mono': {
                name: 'Monochrome Pink',
                colors: ['#E8C4D5']
            },
            'blue_mono': {
                name: 'Monochrome Blue',
                colors: ['#A0B0E8']
            },
            'purple_mono': {
                name: 'Monochrome Purple',
                colors: ['#C4A0E8']
            },
            'black_mono': {
                name: 'Monochrome Black',
                colors: ['#999999']
            },
            'warm_triad': {
                name: 'Warm Triad (with Red)',
                colors: ['#F4E8A0', '#E8C5A0', '#E89090']
            }
        };

        const PALETTE_ORDER = [
            'full_range',
            'light_triad',
            'dark_triad',
            'yellow_blue',
            'unique_triad',
            'yellow_mono',
            'orange_mono',
            'pink_mono',
            'blue_mono',
            'purple_mono',
            'black_mono',
            'warm_triad'
        ];

        let currentPaletteIndex = 0;
        let LENS_COLORS = COLOR_PALETTES[PALETTE_ORDER[currentPaletteIndex]].colors;

        // Seeded random
        function seededRandom(seed) {
            let state = seed;
            return function() {
                state = (state * 9301 + 49297) % 233280;
                return state / 233280;
            };
        }

        let rng = seededRandom(currentSeed);

        // Leg type assignment with probability distribution
        function assignLegType(rng) {
            const r = rng();
            if (r < 0.25) return 'single';        // 25% single straight (center)
            if (r < 0.45) return 'double';        // 20% double straight
            if (r < 0.55) return 'left_only';     // 10% left straight only
            if (r < 0.65) return 'right_only';    // 10% right straight only
            if (r < 0.72) return 'curved_lc';     // 7% curved left-center
            if (r < 0.79) return 'curved_cr';     // 7% curved center-right
            if (r < 0.85) return 'curved_lr';     // 6% curved left-right
            if (r < 0.95) return 'curved_adjacent'; // 10% curved adjacent bridge
            return 'none';                        // 5% no legs
        }

        // Regenerate lenses while keeping anchors static
        function regenerateLenses() {
            if (anchors.length === 0) return;

            // Keep anchors, regenerate rings using CURRENT strategy
            console.log('ðŸ”„ Regenerating lenses with current strategy:', STRATEGIES[currentStrategy].name);
            generateWithStrategy();
        }

        // Cycle to next strategy and regenerate with same anchors
        function cycleStrategy() {
            if (anchors.length === 0) return;

            // Increment strategy (cycle back to 0 after last)
            currentStrategy = (currentStrategy + 1) % STRATEGIES.length;

            console.log('ðŸŽ¯ Switching to strategy:', STRATEGIES[currentStrategy].name);

            // Regenerate with new strategy
            generateWithStrategy();
        }

        // Generate composition using current strategy
        function generateWithStrategy() {
            const strategy = STRATEGIES[currentStrategy];

            console.log('ðŸ“ Generating with strategy:', strategy.name, '| Mode:', strategy.radiusMode, '| Range:', strategy.minLenses, '-', strategy.maxLenses);

            // Generate new lens seed
            lensSeed = Date.now();
            legSeed = Date.now();

            // Use lensSeed for circle packing
            rng = seededRandom(lensSeed);
            attempts = 0;

            rings = [];

            // Apply strategy-specific generation
            const range = strategy.maxLenses - strategy.minLenses;
            const targetCount = Math.floor(rng() * (range + 1)) + strategy.minLenses;

            console.log('ðŸŽ² Target lens count:', targetCount);

            switch(strategy.radiusMode) {
                case 'weighted_random':
                    // Dense Packing, Top-Heavy, Bottom-Heavy, Ring Formation
                    for (let i = 0; i < targetCount; i++) {
                        step();
                    }
                    break;

                case 'large_only':
                    // Sparse Giant - huge lenses only
                    for (let i = 0; i < targetCount; i++) {
                        stepLargeOnly();
                    }
                    break;

                case 'small_only':
                    // Micro Cluster - tiny lenses only
                    // Keep trying until we hit target or max total attempts
                    const maxTotalAttempts = targetCount * 1000; // Allow more attempts
                    let totalAttempts = 0;
                    while (rings.length < targetCount && totalAttempts < maxTotalAttempts) {
                        const beforeCount = rings.length;
                        stepSmallOnly();
                        totalAttempts += 500; // Each step tries 500 times

                        // If we didn't place a lens after a full step, break
                        if (rings.length === beforeCount) {
                            console.log(`âš ï¸ Micro Cluster stopped early: ${rings.length}/${targetCount} lenses placed`);
                            break;
                        }
                    }
                    console.log(`âœ… Micro Cluster: ${rings.length} lenses placed (target: ${targetCount})`);
                    break;

                case 'maximal':
                    // Minimalist - each lens as large as possible
                    for (let i = 0; i < targetCount; i++) {
                        stepMaximal();
                    }
                    break;

                case 'twins':
                    // Twins - only 2-3 repeated sizes
                    generateTwins(targetCount);
                    break;

                case 'apollonian':
                    // Apollonian - 3-anchor tangent base + nested fill
                    generateApollonian(targetCount);
                    break;

                case 'halo':
                    // Halo - one giant lens + swarm of tiny lenses
                    generateHalo(targetCount);
                    break;
            }

            // Regenerate legs and update display
            regenerateLegs();
            updateInfo();
        }

        // Get leg count for a leg type (single=1, double=2, curved=1)
        function getLegCount(legType) {
            if (legType === 'double') return 2;
            if (legType === 'none') return 0;
            return 1; // single, curved_lc, curved_cr, curved_lr, curved_adjacent
        }

        // Find adjacent (tangent) rings - returns index or -1
        function findAdjacentRing(ringIndex) {
            const ring = rings[ringIndex];
            const TANGENT_TOLERANCE = 3; // 3mm tolerance for tangency

            for (let i = 0; i < rings.length; i++) {
                if (i === ringIndex) continue;

                const other = rings[i];
                const dx = ring.x - other.x;
                const dy = ring.y - other.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const expectedDist = ring.radius + other.radius;

                // Check if rings are tangent (within tolerance)
                if (Math.abs(dist - expectedDist) < TANGENT_TOLERANCE) {
                    return i;
                }
            }
            return -1;
        }

        // Track occupied attachment points for each ring
        // occupiedPoints[ringIndex] = Set of 'L', 'C', 'R'
        let occupiedPoints = [];

        // Bridge connections array
        let bridges = [];

        // Regenerate legs while keeping rings and anchors static
        function regenerateLegs() {
            if (rings.length === 0) return;

            // Generate new leg seed
            legSeed = Date.now();
            const legRng = seededRandom(legSeed);

            // First, set all rings to 'none' and clear adjacentRingIndex
            rings.forEach(ring => {
                ring.legType = 'none';
                ring.adjacentRingIndex = -1;
            });

            // Clear bridges and occupied points
            bridges = [];
            occupiedPoints = rings.map(() => new Set());

            // Build legs up to max count
            let currentLegCount = 0;
            const availableIndices = rings.map((_, i) => i);

            // Shuffle available indices
            for (let i = availableIndices.length - 1; i > 0; i--) {
                const j = Math.floor(legRng() * (i + 1));
                [availableIndices[i], availableIndices[j]] = [availableIndices[j], availableIndices[i]];
            }

            // Assign legs until we hit the max count or run out of rings
            for (let i = 0; i < availableIndices.length && currentLegCount < MAX_LEG_COUNT; i++) {
                const ringIndex = availableIndices[i];
                let legType = assignLegType(legRng);

                // If curved_adjacent, check if there's an adjacent ring available
                if (legType === 'curved_adjacent') {
                    const adjacentIndex = findAdjacentRing(ringIndex);
                    if (adjacentIndex !== -1 && rings[adjacentIndex].legType === 'none') {
                        // Valid adjacent pair found
                        rings[ringIndex].adjacentRingIndex = adjacentIndex;
                    } else {
                        // No valid adjacent ring, fallback to regular curved leg
                        const fallbackTypes = ['curved_lc', 'curved_cr', 'curved_lr'];
                        legType = fallbackTypes[Math.floor(legRng() * fallbackTypes.length)];
                    }
                }

                const legCount = getLegCount(legType);

                // Check if adding this leg would exceed max
                if (currentLegCount + legCount <= MAX_LEG_COUNT) {
                    rings[ringIndex].legType = legType;
                    currentLegCount += legCount;

                    // Mark attachment points as occupied
                    markAttachmentPoints(ringIndex, legType);
                } else if (currentLegCount < MAX_LEG_COUNT) {
                    // We have room for a single leg but not a double
                    // Force a single or curved leg
                    const singleLegTypes = ['single', 'curved_lc', 'curved_cr', 'curved_lr'];
                    legType = singleLegTypes[Math.floor(legRng() * singleLegTypes.length)];
                    rings[ringIndex].legType = legType;
                    currentLegCount += 1;

                    // Mark attachment points as occupied
                    markAttachmentPoints(ringIndex, legType);
                }
            }

            // Ensure at least one leg exists
            if (currentLegCount === 0 && rings.length > 0) {
                rings[0].legType = 'single';
                markAttachmentPoints(0, 'single');
            }

            // Now assign random bridges (increased frequency!)
            if (rings.length >= 2 && legRng() < 0.60) { // 60% chance to have bridges
                const maxBridges = Math.min(4, Math.floor(rings.length / 2)); // Allow up to 4 bridges
                const numBridges = Math.floor(legRng() * maxBridges) + 1; // 1 to maxBridges

                for (let b = 0; b < numBridges; b++) {
                    const bridge = assignRandomBridge(legRng);
                    if (bridge) {
                        bridges.push(bridge);

                        // IMPORTANT: Set both lenses to 'none' - the bridge IS their support
                        // A lens cannot have both a bridge AND regular legs
                        rings[bridge.lens1Index].legType = 'none';
                        rings[bridge.lens2Index].legType = 'none';

                        // Clear their occupied points from regular legs (they now only have bridge attachments)
                        if (occupiedPoints[bridge.lens1Index]) {
                            occupiedPoints[bridge.lens1Index].clear();
                        }
                        if (occupiedPoints[bridge.lens2Index]) {
                            occupiedPoints[bridge.lens2Index].clear();
                        }

                        // Mark bridge attachment points as occupied
                        occupiedPoints[bridge.lens1Index].add(bridge.lens1Position);
                        occupiedPoints[bridge.lens2Index].add(bridge.lens2Position);

                        currentLegCount += 2; // Each bridge counts as 2 legs
                        if (currentLegCount >= MAX_LEG_COUNT) break;
                    }
                }
            }

            draw();
        }

        // Mark attachment points as occupied based on leg type
        function markAttachmentPoints(ringIndex, legType) {
            switch(legType) {
                case 'single':
                    occupiedPoints[ringIndex].add('C');
                    break;
                case 'double':
                    occupiedPoints[ringIndex].add('L');
                    occupiedPoints[ringIndex].add('R');
                    break;
                case 'left_only':
                    occupiedPoints[ringIndex].add('L');
                    break;
                case 'right_only':
                    occupiedPoints[ringIndex].add('R');
                    break;
                case 'curved_lc':
                    occupiedPoints[ringIndex].add('L');
                    occupiedPoints[ringIndex].add('C');
                    break;
                case 'curved_cr':
                    occupiedPoints[ringIndex].add('C');
                    occupiedPoints[ringIndex].add('R');
                    break;
                case 'curved_lr':
                    occupiedPoints[ringIndex].add('L');
                    occupiedPoints[ringIndex].add('R');
                    break;
            }
        }

        // Assign a random bridge between two lenses
        function assignRandomBridge(rng) {
            if (rings.length < 2) return null;

            // Try to find two lenses with available attachment points
            const maxAttempts = 50;
            for (let attempt = 0; attempt < maxAttempts; attempt++) {
                // Pick two random distinct lenses
                const lens1Index = Math.floor(rng() * rings.length);
                let lens2Index = Math.floor(rng() * rings.length);

                // Ensure different lenses
                if (lens1Index === lens2Index) {
                    lens2Index = (lens2Index + 1) % rings.length;
                }

                // Get available positions for each lens
                const positions = ['L', 'C', 'R'];
                const availablePos1 = positions.filter(p => !occupiedPoints[lens1Index].has(p));
                const availablePos2 = positions.filter(p => !occupiedPoints[lens2Index].has(p));

                if (availablePos1.length > 0 && availablePos2.length > 0) {
                    // Pick random available positions
                    const pos1 = availablePos1[Math.floor(rng() * availablePos1.length)];
                    const pos2 = availablePos2[Math.floor(rng() * availablePos2.length)];

                    // Mark as occupied
                    occupiedPoints[lens1Index].add(pos1);
                    occupiedPoints[lens2Index].add(pos2);

                    return {
                        lens1Index: lens1Index,
                        lens1Position: pos1,
                        lens2Index: lens2Index,
                        lens2Position: pos2
                    };
                }
            }

            return null; // Couldn't find available positions
        }

        // Get the attachment point coordinates for a bridge
        function getBridgeAttachmentPoint(lens, position, legOffset) {
            switch(position) {
                case 'L':
                    // Left edge
                    return {
                        x: lens.x - (lens.radius - legOffset),
                        y: lens.y
                    };
                case 'C':
                    // Center bottom
                    return {
                        x: lens.x,
                        y: lens.y + (lens.radius - legOffset)
                    };
                case 'R':
                    // Right edge
                    return {
                        x: lens.x + (lens.radius - legOffset),
                        y: lens.y
                    };
            }
        }

        // Cycle to next color palette
        function cyclePalette() {
            currentPaletteIndex = (currentPaletteIndex + 1) % PALETTE_ORDER.length;
            const paletteKey = PALETTE_ORDER[currentPaletteIndex];
            LENS_COLORS = COLOR_PALETTES[paletteKey].colors;

            // Reassign colors to existing lenses
            rings.forEach((ring, i) => {
                ring.color = LENS_COLORS[i % LENS_COLORS.length];
            });

            console.log(`Switched to palette: ${COLOR_PALETTES[paletteKey].name}`);
            updateInfo();
            draw();
        }

        function generate() {
            currentSeed = Date.now();
            lensSeed = Date.now();
            legSeed = Date.now();
            rng = seededRandom(currentSeed);
            attempts = 0;

            // ðŸŒŒ CONSTELLATION PATTERNS - 6 different anchor formations
            const constellationType = Math.floor(rng() * 6);
            anchors = [];

            switch(constellationType) {
                case 0: // Classic Triangle - CONSTRAINED to 152mm workspace
                    const MAX_ANCHOR_POS = 71; // mm from center (76mm workspace/2 - 5mm anchor radius)
                    const baseRadius = rng() * 30 + 35; // 35-65mm (was 40-80, reduced to fit)
                    const jitter = 0.3;
                    const variation = 15; // Reduced from 20
                    for (let i = 0; i < 3; i++) {
                        const angle = (i / 3) * Math.PI * 2 + (rng() - 0.5) * jitter;
                        const radius = Math.min(baseRadius + (rng() - 0.5) * variation, MAX_ANCHOR_POS);
                        anchors.push({
                            x: Math.cos(angle) * radius,
                            y: Math.sin(angle) * radius,
                            radius: ANCHOR_DIAMETER / 2
                        });
                    }
                    console.log('ðŸ”º Classic Triangle');
                    break;

                case 1: // Tight Cluster (close together)
                    const clusterRadius = rng() * 15 + 15;
                    for (let i = 0; i < 3; i++) {
                        const angle = (i / 3) * Math.PI * 2 + (rng() - 0.5) * 0.5;
                        anchors.push({
                            x: Math.cos(angle) * clusterRadius,
                            y: Math.sin(angle) * clusterRadius,
                            radius: ANCHOR_DIAMETER / 2
                        });
                    }
                    console.log('â­ Tight Cluster');
                    break;

                case 2: // Wide Triangle (spread out) - CONSTRAINED
                    const wideRadius = rng() * 15 + 55; // 55-70mm (was 65-85, reduced to fit)
                    for (let i = 0; i < 3; i++) {
                        const angle = (i / 3) * Math.PI * 2 + (rng() - 0.5) * 0.2;
                        anchors.push({
                            x: Math.cos(angle) * wideRadius,
                            y: Math.sin(angle) * wideRadius,
                            radius: ANCHOR_DIAMETER / 2
                        });
                    }
                    console.log('ðŸ”¼ Wide Triangle');
                    break;

                case 3: // Linear (nearly straight line) - CONSTRAINED
                    const lineAngle = rng() * Math.PI * 2;
                    const spacing = rng() * 15 + 25; // 25-40mm spacing (was 30-50, reduced)
                    for (let i = 0; i < 3; i++) {
                        const offset = (i - 1) * spacing;
                        const perpJitter = (rng() - 0.5) * 10;
                        let x = Math.cos(lineAngle) * offset + Math.cos(lineAngle + Math.PI/2) * perpJitter;
                        let y = Math.sin(lineAngle) * offset + Math.sin(lineAngle + Math.PI/2) * perpJitter;
                        // Clamp to workspace
                        const MAX_POS = 71;
                        x = Math.max(-MAX_POS, Math.min(MAX_POS, x));
                        y = Math.max(-MAX_POS, Math.min(MAX_POS, y));
                        anchors.push({
                            x: x,
                            y: y,
                            radius: ANCHOR_DIAMETER / 2
                        });
                    }
                    console.log('â” Linear Formation');
                    break;

                case 4: // Asymmetric (one far, two close) - CONSTRAINED
                    const pairAngle = rng() * Math.PI * 2;
                    const pairRadius = rng() * 15 + 35; // 35-50mm (was 40-55, reduced)
                    const pairSeparation = 20; // Reduced from 25
                    anchors.push({
                        x: Math.cos(pairAngle) * pairRadius - Math.cos(pairAngle + Math.PI/2) * (pairSeparation/2),
                        y: Math.sin(pairAngle) * pairRadius - Math.sin(pairAngle + Math.PI/2) * (pairSeparation/2),
                        radius: ANCHOR_DIAMETER / 2
                    });
                    anchors.push({
                        x: Math.cos(pairAngle) * pairRadius + Math.cos(pairAngle + Math.PI/2) * (pairSeparation/2),
                        y: Math.sin(pairAngle) * pairRadius + Math.sin(pairAngle + Math.PI/2) * (pairSeparation/2),
                        radius: ANCHOR_DIAMETER / 2
                    });
                    const soloAngle = pairAngle + Math.PI;
                    const soloRadius = rng() * 15 + 55; // 55-70mm (was 60-80, reduced to fit)
                    anchors.push({
                        x: Math.cos(soloAngle) * soloRadius,
                        y: Math.sin(soloAngle) * soloRadius,
                        radius: ANCHOR_DIAMETER / 2
                    });
                    console.log('âš¡ Asymmetric');
                    break;

                case 5: // Right Triangle (one 90Â° corner) - CONSTRAINED
                    const MAX_RT_POS = 71;
                    const cornerX = (rng() - 0.5) * 60; // Â±30mm (was Â±40, reduced)
                    const cornerY = (rng() - 0.5) * 60; // Â±30mm (was Â±40, reduced)
                    const leg1Length = rng() * 25 + 30; // 30-55mm (was 40-70, reduced)
                    const leg2Length = rng() * 25 + 30; // 30-55mm (was 40-70, reduced)
                    const rotation = rng() * Math.PI * 2;

                    // Corner anchor
                    anchors.push({
                        x: cornerX,
                        y: cornerY,
                        radius: ANCHOR_DIAMETER / 2
                    });

                    // Leg 1 anchor - clamp to workspace
                    let leg1X = cornerX + Math.cos(rotation) * leg1Length;
                    let leg1Y = cornerY + Math.sin(rotation) * leg1Length;
                    leg1X = Math.max(-MAX_RT_POS, Math.min(MAX_RT_POS, leg1X));
                    leg1Y = Math.max(-MAX_RT_POS, Math.min(MAX_RT_POS, leg1Y));
                    anchors.push({
                        x: leg1X,
                        y: leg1Y,
                        radius: ANCHOR_DIAMETER / 2
                    });

                    // Leg 2 anchor - clamp to workspace
                    let leg2X = cornerX + Math.cos(rotation + Math.PI/2) * leg2Length;
                    let leg2Y = cornerY + Math.sin(rotation + Math.PI/2) * leg2Length;
                    leg2X = Math.max(-MAX_RT_POS, Math.min(MAX_RT_POS, leg2X));
                    leg2Y = Math.max(-MAX_RT_POS, Math.min(MAX_RT_POS, leg2Y));
                    anchors.push({
                        x: leg2X,
                        y: leg2Y,
                        radius: ANCHOR_DIAMETER / 2
                    });
                    console.log('ðŸ“ Right Triangle');
                    break;
            }

            // Generate rings using current strategy
            generateWithStrategy();
        }

        // Export functions
        function exportJSON() {
            // Create JSON structure compatible with Python pipeline
            const jsonData = {
                layers: [{
                    frames: rings.map(ring => {
                        return {
                            radius: ring.radius,
                            position: {
                                x: ring.x,
                                y: ring.y
                            },
                            color: ring.color,
                            legType: ring.legType,
                            adjacentRingIndex: ring.adjacentRingIndex !== undefined ? ring.adjacentRingIndex : -1
                        };
                    })
                }],
                bridges: bridges || [],
                anchors: anchors.map(anchor => ({
                    position: {
                        x: anchor.x,
                        y: anchor.y
                    },
                    radius: anchor.radius
                })),
                metadata: {
                    seed: currentSeed,
                    lensSeed: lensSeed,
                    legSeed: legSeed,
                    timestamp: new Date().toISOString()
                }
            };

            // Create and download JSON file
            const jsonString = JSON.stringify(jsonData, null, 2);
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `composition_${currentSeed}.json`;
            link.click();
            URL.revokeObjectURL(url);

            console.log('JSON exported:', jsonData);
        }

        function exportPNG() {
            // Create a temporary canvas with white background
            const exportCanvas = document.createElement('canvas');
            exportCanvas.width = canvas.width;
            exportCanvas.height = canvas.height;
            const exportCtx = exportCanvas.getContext('2d');

            // Fill with white background
            exportCtx.fillStyle = '#ffffff';
            exportCtx.fillRect(0, 0, exportCanvas.width, exportCanvas.height);

            // Draw the current canvas content on top
            exportCtx.drawImage(canvas, 0, 0);

            // Create thumbnail (cropped with 20px border)
            createThumbnail(exportCanvas);

            // Convert to PNG and download
            exportCanvas.toBlob((blob) => {
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `composition_${currentSeed}.png`;
                link.click();
                URL.revokeObjectURL(url);
            }, 'image/png');

            console.log('PNG exported');
        }

        function createThumbnail(sourceCanvas) {
            if (rings.length === 0) return;

            // Capture the full 152mm Ã— 152mm workspace (BOUNDARY Ã— BOUNDARY)
            const workspaceSize = BOUNDARY * SCALE; // 152mm Ã— 3.5 = 532px

            // Calculate workspace bounds centered on canvas
            const minX = CENTER_X - (workspaceSize / 2);
            const minY = CENTER_Y - (workspaceSize / 2);

            // Create thumbnail canvas (200Ã—200px for the 152Ã—152mm workspace)
            const thumbCanvas = document.createElement('canvas');
            thumbCanvas.width = 200;
            thumbCanvas.height = 200;
            const thumbCtx = thumbCanvas.getContext('2d');

            // Draw workspace region scaled down to 200Ã—200
            thumbCtx.drawImage(
                sourceCanvas,
                minX, minY, workspaceSize, workspaceSize,
                0, 0, 200, 200
            );

            // Convert to data URL
            const dataURL = thumbCanvas.toDataURL('image/png');

            // Add to thumbnails array (max 4)
            thumbnails.push({
                dataURL: dataURL,
                seed: currentSeed
            });

            // Keep only last 6
            if (thumbnails.length > 6) {
                thumbnails.shift();
            }

            // Update gallery display
            updateThumbnailGallery();
        }

        function updateThumbnailGallery() {
            const gallery = document.getElementById('thumbnail-gallery');
            gallery.innerHTML = '';

            thumbnails.forEach((thumb, index) => {
                const item = document.createElement('div');
                item.className = 'thumbnail-item';

                const img = document.createElement('img');
                img.className = 'thumbnail-image';
                img.src = thumb.dataURL;

                const label = document.createElement('div');
                label.className = 'thumbnail-label';
                label.textContent = `Seed: ${thumb.seed}`;

                item.appendChild(img);
                item.appendChild(label);
                gallery.appendChild(item);
            });
        }

        function exportLensSVG() {
            if (rings.length === 0) {
                console.log('No lenses to export');
                return;
            }

            // Color hex to name mapping
            const colorNames = {
                '#F4E8A0': 'Yellow',
                '#E8C5A0': 'Orange',
                '#E8C4D5': 'Pink',
                '#A0B0E8': 'Blue',
                '#C4A0E8': 'Purple',
                '#999999': 'Gray',
                '#E89090': 'Red'
            };

            // 8" x 10" canvas in mm (203.2mm x 254mm)
            const canvasWidth = 203.2;
            const canvasHeight = 254;

            // Calculate composition bounds to center it on canvas
            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;
            rings.forEach(ring => {
                minX = Math.min(minX, ring.x - ring.radius);
                maxX = Math.max(maxX, ring.x + ring.radius);
                minY = Math.min(minY, ring.y - ring.radius);
                maxY = Math.max(maxY, ring.y + ring.radius);
            });

            const compositionWidth = maxX - minX;
            const compositionHeight = maxY - minY;
            const compositionCenterX = (minX + maxX) / 2;
            const compositionCenterY = (minY + maxY) / 2;

            // Center offset for SVG
            const offsetX = canvasWidth / 2 - compositionCenterX;
            const offsetY = canvasHeight / 2 - compositionCenterY;

            // Start SVG
            let svg = `<?xml version="1.0" encoding="UTF-8"?>
<svg width="${canvasWidth}mm" height="${canvasHeight}mm" viewBox="0 0 ${canvasWidth} ${canvasHeight}" xmlns="http://www.w3.org/2000/svg">
  <rect width="${canvasWidth}" height="${canvasHeight}" fill="white"/>

`;

            // Add each lens as a circle with label
            rings.forEach((ring, index) => {
                const cx = ring.x + offsetX;
                const cy = ring.y + offsetY;
                // Lens radius = frame radius - 1.2mm (diameter reduction of 2.4mm)
                const lensRadius = ring.radius - 1.2;
                const diameter = (lensRadius * 2).toFixed(2);
                const colorName = colorNames[ring.color] || ring.color;

                // Circle with color fill and black stroke
                svg += `  <!-- Lens ${index + 1} -->\n`;
                svg += `  <circle cx="${cx.toFixed(3)}" cy="${cy.toFixed(3)}" r="${lensRadius.toFixed(3)}" fill="${ring.color}" stroke="black" stroke-width="0.5"/>\n`;

                // Text label - diameter and color
                svg += `  <text x="${cx.toFixed(3)}" y="${cy.toFixed(3)}" text-anchor="middle" dominant-baseline="middle" font-family="Arial" font-size="8" fill="black">\n`;
                svg += `    ${diameter}mm / ${colorName}\n`;
                svg += `  </text>\n\n`;
            });

            // Close SVG
            svg += `</svg>`;

            // Download SVG file
            const blob = new Blob([svg], { type: 'image/svg+xml' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `lens_template_${currentSeed}.svg`;
            link.click();
            URL.revokeObjectURL(url);

            console.log(`Lens SVG exported: ${rings.length} lenses`);
        }

        function exportAllFiles() {
            if (rings.length === 0) {
                console.log('No composition to export');
                return;
            }

            console.log('Exporting all files...');

            // Export PNG (also creates thumbnail)
            exportPNG();

            // Export JSON
            exportJSON();

            // Export SVG
            exportLensSVG();

            // Export SCAD
            exportSCAD();

            // Export OpenSCAD automation script
            exportOpenSCADScript();

            console.log('All files exported! Run the render.sh script to generate STL files.');
        }

        function exportSCAD() {
            if (rings.length === 0) {
                console.log('No composition to export as SCAD');
                return;
            }

            // Generate OpenSCAD script
            const frames = rings.map(ring => ({
                radius: ring.radius,
                position: { x: ring.x, y: ring.y },
                legType: ring.legType,
                adjacentRingIndex: ring.adjacentRingIndex !== undefined ? ring.adjacentRingIndex : -1
            }));

            const anchorsData = anchors.map(anchor => ({
                position: { x: anchor.x, y: anchor.y },
                radius: anchor.radius
            }));

            let scad = `// SONAR 3D Composition - OpenSCAD Export
// Generated: ${new Date().toISOString()}
// Source: seed_${currentSeed}

// ========================================
// EXPORT OPTIONS - Toggle what to generate
// ========================================

EXPORT_STRUCTURE = true;   // Frame structure with legs/bridges/anchors
EXPORT_WASHERS = false;    // Lens washers (set to true, structure to false)

// ========================================
// PHYSICAL CONSTANTS (all units in mm)
// ========================================

frame_height = 3.175;      // Thickness of lens frames
frame_width = 1.2;         // Wall thickness
channel_depth = 1.5875;    // Depth of lens channel
anchor_diameter = 6.36;    // Anchor outer diameter
anchor_hole_size = 2.8;    // Square hole in anchor
leg_width = 1.2;           // Leg thickness
ground_y = 76;             // Ground plane Y coordinate
overlap = 0.1;             // Small overlap for CSG union operations

// Rendering quality ($fn = segments for curves)
$fn = 80;

// ========================================
// MAIN COMPOSITION
// ========================================

if (EXPORT_STRUCTURE) {
    difference() {
        all_solids();
        all_voids();
    }
}

if (EXPORT_WASHERS) {
    washers();
}

// ========================================
// ALL SOLID PARTS
// ========================================

module all_solids() {
    union() {
        // Lens frame outer cylinders
        lens_frames_outer();

        // Legs
        legs();

        // Bridges
        bridges();

        // Anchor outer cylinders
        anchors_outer();
    }
}

// ========================================
// ALL VOID PARTS (CUTOUTS)
// ========================================

module all_voids() {
    union() {
        // Lens channels
        lens_channels();

        // Lens inner holes
        lens_holes();

        // Anchor square holes
        anchor_holes();
    }
}

// ========================================
// LENS FRAMES (OUTER CYLINDERS)
// ========================================

module lens_frames_outer() {
`;

            // Generate lens frame outer cylinders
            frames.forEach((frame, index) => {
                const x = frame.position.x;
                const y = frame.position.y;
                const r = frame.radius + 0.1; // Add overlap for CSG union
                scad += `    // Lens ${index + 1}: r=${frame.radius.toFixed(2)}mm at (${x.toFixed(2)}, ${y.toFixed(2)})\n`;
                scad += `    translate([${x.toFixed(3)}, ${y.toFixed(3)}, 0])\n`;
                scad += `        cylinder(r=${r.toFixed(3)}, h=frame_height);\n\n`;
            });

            scad += `}

// ========================================
// LENS CHANNELS (VOIDS)
// ========================================

module lens_channels() {
`;

            // Generate lens channels
            frames.forEach((frame, index) => {
                const x = frame.position.x;
                const y = frame.position.y;
                const channelRadius = frame.radius - 1.2;
                scad += `    // Lens ${index + 1} channel\n`;
                scad += `    translate([${x.toFixed(3)}, ${y.toFixed(3)}, channel_depth])\n`;
                scad += `        cylinder(r=${channelRadius.toFixed(3)}, h=frame_height);\n\n`;
            });

            scad += `}

// ========================================
// LENS INNER HOLES (VOIDS)
// ========================================

module lens_holes() {
`;

            // Generate lens inner holes
            frames.forEach((frame, index) => {
                const x = frame.position.x;
                const y = frame.position.y;
                const innerRadius = frame.radius - 2.4;
                scad += `    // Lens ${index + 1} inner hole\n`;
                scad += `    translate([${x.toFixed(3)}, ${y.toFixed(3)}, -0.5])\n`;
                scad += `        cylinder(r=${innerRadius.toFixed(3)}, h=frame_height + 1);\n\n`;
            });

            scad += `}

// ========================================
// LEGS
// ========================================

module legs() {
`;

            // Generate legs (copying logic from scadx.html)
            frames.forEach((frame, index) => {
                const legType = frame.legType;
                if (legType === 'none') return;

                const x = frame.position.x;
                const y = frame.position.y;
                const r = frame.radius;
                const legOffset = 0.6;

                scad += `    // Leg for lens ${index + 1}: type=${legType}\n`;

                switch (legType) {
                    case 'single':
                        const singleLegHeight = 76 - (y - r) + 0.1;
                        if (singleLegHeight > 0) {
                            const legStartY = y - r;
                            scad += `    translate([${(x - 0.6).toFixed(3)}, ${legStartY.toFixed(3)}, 0])\n`;
                            scad += `        cube([leg_width, ${singleLegHeight.toFixed(3)}, frame_height]);\n\n`;
                        }
                        break;

                    case 'double':
                        const leftX = x - (r - legOffset);
                        const rightX = x + (r - legOffset);
                        const doubleLegHeight = 76 - y + 0.1;
                        if (doubleLegHeight > 0) {
                            scad += `    translate([${(leftX - 0.6).toFixed(3)}, ${y.toFixed(3)}, 0])\n`;
                            scad += `        cube([leg_width, ${doubleLegHeight.toFixed(3)}, frame_height]);\n`;
                            scad += `    translate([${(rightX - 0.6).toFixed(3)}, ${y.toFixed(3)}, 0])\n`;
                            scad += `        cube([leg_width, ${doubleLegHeight.toFixed(3)}, frame_height]);\n\n`;
                        }
                        break;

                    case 'left_only':
                        const leftOnlyX = x - (r - legOffset);
                        const leftOnlyHeight = 76 - y + 0.1;
                        if (leftOnlyHeight > 0) {
                            scad += `    translate([${(leftOnlyX - 0.6).toFixed(3)}, ${y.toFixed(3)}, 0])\n`;
                            scad += `        cube([leg_width, ${leftOnlyHeight.toFixed(3)}, frame_height]);\n\n`;
                        }
                        break;

                    case 'right_only':
                        const rightOnlyX = x + (r - legOffset);
                        const rightOnlyHeight = 76 - y + 0.1;
                        if (rightOnlyHeight > 0) {
                            scad += `    translate([${(rightOnlyX - 0.6).toFixed(3)}, ${y.toFixed(3)}, 0])\n`;
                            scad += `        cube([leg_width, ${rightOnlyHeight.toFixed(3)}, frame_height]);\n\n`;
                        }
                        break;

                    case 'curved_lc':
                        const leftEdgeX_lc = x - (r - legOffset);
                        const leftEdgeY_lc = y;
                        const centerBottomX_lc = x;
                        const centerBottomY_lc = y + (r - legOffset);

                        const arcRadius_lc = (centerBottomX_lc - leftEdgeX_lc) / 2;
                        const arcCenterX_lc = leftEdgeX_lc + arcRadius_lc;
                        const arcCenterY_lc = 76 - arcRadius_lc;

                        if (arcCenterY_lc > y + r) {
                            const leftLegHeight_lc = arcCenterY_lc - leftEdgeY_lc + 0.1;
                            scad += `    // curved_lc: Left vertical\n`;
                            scad += `    translate([${(leftEdgeX_lc - 0.6).toFixed(3)}, ${leftEdgeY_lc.toFixed(3)}, 0])\n`;
                            scad += `        cube([leg_width, ${leftLegHeight_lc.toFixed(3)}, frame_height]);\n\n`;

                            const centerLegHeight_lc = arcCenterY_lc - centerBottomY_lc + 0.1;
                            scad += `    // curved_lc: Center vertical\n`;
                            scad += `    translate([${(centerBottomX_lc - 0.6).toFixed(3)}, ${centerBottomY_lc.toFixed(3)}, 0])\n`;
                            scad += `        cube([leg_width, ${centerLegHeight_lc.toFixed(3)}, frame_height]);\n\n`;

                            scad += `    // curved_lc: U-shaped arc\n`;
                            scad += `    translate([${arcCenterX_lc.toFixed(3)}, ${arcCenterY_lc.toFixed(3)}, 0])\n`;
                            scad += `        rotate([0, 0, 0])\n`;
                            scad += `        rotate_extrude(angle=180)\n`;
                            scad += `        translate([${(arcRadius_lc - 0.6).toFixed(3)}, 0, 0])\n`;
                            scad += `        square([leg_width, frame_height], center=false);\n\n`;
                        }
                        break;

                    case 'curved_cr':
                        const centerBottomX_cr = x;
                        const centerBottomY_cr = y + (r - legOffset);
                        const rightEdgeX_cr = x + (r - legOffset);
                        const rightEdgeY_cr = y;

                        const arcRadius_cr = (rightEdgeX_cr - centerBottomX_cr) / 2;
                        const arcCenterX_cr = centerBottomX_cr + arcRadius_cr;
                        const arcCenterY_cr = 76 - arcRadius_cr;

                        if (arcCenterY_cr > y + r) {
                            const centerLegHeight_cr = arcCenterY_cr - centerBottomY_cr + 0.1;
                            scad += `    // curved_cr: Center vertical\n`;
                            scad += `    translate([${(centerBottomX_cr - 0.6).toFixed(3)}, ${centerBottomY_cr.toFixed(3)}, 0])\n`;
                            scad += `        cube([leg_width, ${centerLegHeight_cr.toFixed(3)}, frame_height]);\n\n`;

                            const rightLegHeight_cr = arcCenterY_cr - rightEdgeY_cr + 0.1;
                            scad += `    // curved_cr: Right vertical\n`;
                            scad += `    translate([${(rightEdgeX_cr - 0.6).toFixed(3)}, ${rightEdgeY_cr.toFixed(3)}, 0])\n`;
                            scad += `        cube([leg_width, ${rightLegHeight_cr.toFixed(3)}, frame_height]);\n\n`;

                            scad += `    // curved_cr: U-shaped arc\n`;
                            scad += `    translate([${arcCenterX_cr.toFixed(3)}, ${arcCenterY_cr.toFixed(3)}, 0])\n`;
                            scad += `        rotate([0, 0, 0])\n`;
                            scad += `        rotate_extrude(angle=180)\n`;
                            scad += `        translate([${(arcRadius_cr - 0.6).toFixed(3)}, 0, 0])\n`;
                            scad += `        square([leg_width, frame_height], center=false);\n\n`;
                        }
                        break;

                    case 'curved_lr':
                        const leftEdgeX_lr = x - (r - legOffset);
                        const leftEdgeY_lr = y;
                        const rightEdgeX_lr = x + (r - legOffset);
                        const rightEdgeY_lr = y;

                        const arcRadius_lr = (rightEdgeX_lr - leftEdgeX_lr) / 2;
                        const arcCenterX_lr = x;
                        const arcCenterY_lr = 76 - arcRadius_lr;

                        if (arcCenterY_lr > y + r) {
                            const leftLegHeight_lr = arcCenterY_lr - leftEdgeY_lr + 0.1;
                            scad += `    // curved_lr: Left vertical\n`;
                            scad += `    translate([${(leftEdgeX_lr - 0.6).toFixed(3)}, ${leftEdgeY_lr.toFixed(3)}, 0])\n`;
                            scad += `        cube([leg_width, ${leftLegHeight_lr.toFixed(3)}, frame_height]);\n\n`;

                            const rightLegHeight_lr = arcCenterY_lr - rightEdgeY_lr + 0.1;
                            scad += `    // curved_lr: Right vertical\n`;
                            scad += `    translate([${(rightEdgeX_lr - 0.6).toFixed(3)}, ${rightEdgeY_lr.toFixed(3)}, 0])\n`;
                            scad += `        cube([leg_width, ${rightLegHeight_lr.toFixed(3)}, frame_height]);\n\n`;

                            scad += `    // curved_lr: Wide U-shaped arc\n`;
                            scad += `    translate([${arcCenterX_lr.toFixed(3)}, ${arcCenterY_lr.toFixed(3)}, 0])\n`;
                            scad += `        rotate([0, 0, 0])\n`;
                            scad += `        rotate_extrude(angle=180)\n`;
                            scad += `        translate([${(arcRadius_lr - 0.6).toFixed(3)}, 0, 0])\n`;
                            scad += `        square([leg_width, frame_height], center=false);\n\n`;
                        }
                        break;

                    case 'curved_adjacent':
                        if (frame.adjacentRingIndex !== -1 && frame.adjacentRingIndex < frames.length) {
                            const adjacent = frames[frame.adjacentRingIndex];
                            const dx = adjacent.position.x - x;
                            const dy = adjacent.position.y - y;
                            const dist = Math.sqrt(dx * dx + dy * dy);

                            const tangentX = x + (dx / dist) * r;
                            const tangentY = y + (dy / dist) * r;

                            const legSpacing = 3;
                            const leg1X = tangentX - legSpacing / 2;
                            const leg2X = tangentX + legSpacing / 2;

                            const bridgeArcRadius = legSpacing / 2;
                            const bridgeArcCenterY = 76 - bridgeArcRadius;

                            const ring1Bottom = y + r;
                            const ring2Bottom = adjacent.position.y + adjacent.radius;

                            if (bridgeArcCenterY > ring1Bottom && bridgeArcCenterY > ring2Bottom) {
                                const leg1Height = bridgeArcCenterY - tangentY + 0.1;
                                scad += `    // curved_adjacent: Left vertical\n`;
                                scad += `    translate([${(leg1X - 0.6).toFixed(3)}, ${tangentY.toFixed(3)}, 0])\n`;
                                scad += `        cube([leg_width, ${leg1Height.toFixed(3)}, frame_height]);\n\n`;

                                const leg2Height = bridgeArcCenterY - tangentY + 0.1;
                                scad += `    // curved_adjacent: Right vertical\n`;
                                scad += `    translate([${(leg2X - 0.6).toFixed(3)}, ${tangentY.toFixed(3)}, 0])\n`;
                                scad += `        cube([leg_width, ${leg2Height.toFixed(3)}, frame_height]);\n\n`;

                                scad += `    // curved_adjacent: Bridge arc\n`;
                                scad += `    translate([${tangentX.toFixed(3)}, ${bridgeArcCenterY.toFixed(3)}, 0])\n`;
                                scad += `        rotate([0, 0, 0])\n`;
                                scad += `        rotate_extrude(angle=180)\n`;
                                scad += `        translate([${(bridgeArcRadius - 0.6).toFixed(3)}, 0, 0])\n`;
                                scad += `        square([leg_width, frame_height], center=false);\n\n`;
                            }
                        } else {
                            // No adjacent ring found - skip leg generation
                            // (This lens likely has a bridge or should have legType='none')
                            scad += `    // curved_adjacent: No adjacent ring found, skipping leg\n\n`;
                        }
                        break;
                }
            });

            scad += `}

// ========================================
// BRIDGES (Random lens-to-lens connections)
// ========================================

module bridges() {
`;

            // Generate bridges if they exist
            if (bridges && bridges.length > 0) {
                bridges.forEach((bridge, bridgeIndex) => {
                    const lens1 = frames[bridge.lens1Index];
                    const lens2 = frames[bridge.lens2Index];

                    if (!lens1 || !lens2) return;

                    scad += `    // Bridge ${bridgeIndex + 1}: lens ${bridge.lens1Index + 1}[${bridge.lens1Position}] to lens ${bridge.lens2Index + 1}[${bridge.lens2Position}]\n`;

                    const legOffset = 0.6;
                    const point1 = getBridgeAttachmentPointForSCAD(lens1, bridge.lens1Position, legOffset);
                    const point2 = getBridgeAttachmentPointForSCAD(lens2, bridge.lens2Position, legOffset);

                    const x1 = point1.x;
                    const y1 = point1.y;
                    const x2 = point2.x;
                    const y2 = point2.y;

                    const arcRadius = Math.abs(x2 - x1) / 2;
                    const arcCenterX = (x1 + x2) / 2;
                    const arcCenterY = 76 - arcRadius;

                    const lens1Bottom = lens1.position.y + lens1.radius;
                    const lens2Bottom = lens2.position.y + lens2.radius;

                    if (arcCenterY > lens1Bottom && arcCenterY > lens2Bottom && arcRadius > 0) {
                        const leg1Height = arcCenterY - y1 + 0.1;
                        if (leg1Height > 0) {
                            scad += `    translate([${(x1 - 0.6).toFixed(3)}, ${y1.toFixed(3)}, 0])\n`;
                            scad += `        cube([leg_width, ${leg1Height.toFixed(3)}, frame_height]);\n\n`;
                        }

                        const leg2Height = arcCenterY - y2 + 0.1;
                        if (leg2Height > 0) {
                            scad += `    translate([${(x2 - 0.6).toFixed(3)}, ${y2.toFixed(3)}, 0])\n`;
                            scad += `        cube([leg_width, ${leg2Height.toFixed(3)}, frame_height]);\n\n`;
                        }

                        scad += `    translate([${arcCenterX.toFixed(3)}, ${arcCenterY.toFixed(3)}, 0])\n`;
                        scad += `        rotate([0, 0, 0])\n`;
                        scad += `        rotate_extrude(angle=180)\n`;
                        scad += `        translate([${(arcRadius - 0.6).toFixed(3)}, 0, 0])\n`;
                        scad += `        square([leg_width, frame_height], center=false);\n\n`;
                    }
                });
            }

            scad += `}

// ========================================
// ANCHORS
// ========================================

module anchors_outer() {
`;

            // Generate anchor outer cylinders
            anchorsData.forEach((anchor, index) => {
                const x = anchor.position.x;
                const y = anchor.position.y;
                scad += `    // Anchor ${index + 1}\n`;
                scad += `    translate([${x.toFixed(3)}, ${y.toFixed(3)}, 0])\n`;
                scad += `        cylinder(r=anchor_diameter/2 + overlap, h=frame_height);\n\n`;
            });

            scad += `}

module anchor_holes() {
`;

            // Generate anchor square holes
            anchorsData.forEach((anchor, index) => {
                const x = anchor.position.x;
                const y = anchor.position.y;
                scad += `    // Anchor hole ${index + 1}\n`;
                scad += `    translate([${(x - 1.4).toFixed(3)}, ${(y - 1.4).toFixed(3)}, -0.5])\n`;
                scad += `        cube([anchor_hole_size, anchor_hole_size, frame_height + 2]);\n\n`;
            });

            scad += `}

// ========================================
// LENS WASHERS (for holding lenses in place)
// ========================================

module washers() {
`;

            // Generate washers for each lens
            frames.forEach((frame, index) => {
                const x = frame.position.x;
                const y = frame.position.y;
                const outerRadius = frame.radius - 1.2;
                const innerRadius = outerRadius - 1.2;
                const washerHeight = 1.5875;

                scad += `    // Washer for lens ${index + 1}\n`;
                scad += `    translate([${x.toFixed(3)}, ${y.toFixed(3)}, 0])\n`;
                scad += `        difference() {\n`;
                scad += `            cylinder(r=${outerRadius.toFixed(3)}, h=${washerHeight.toFixed(4)});\n`;
                scad += `            translate([0, 0, -0.5])\n`;
                scad += `                cylinder(r=${innerRadius.toFixed(3)}, h=${(washerHeight + 1).toFixed(4)});\n`;
                scad += `        }\n\n`;
            });

            scad += `}

// ========================================
// END OF SCRIPT
// ========================================
`;

            // Download SCAD file
            const blob = new Blob([scad], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `composition_${currentSeed}.scad`;
            link.click();
            URL.revokeObjectURL(url);

            console.log('OpenSCAD script exported');
        }

        function exportOpenSCADScript() {
            if (rings.length === 0) {
                console.log('No composition for OpenSCAD automation');
                return;
            }

            const scadFilename = `composition_${currentSeed}.scad`;
            const frameFilename = `frame_${currentSeed}.stl`;
            const ringsFilename = `rings_${currentSeed}.stl`;

            // Create bash script that will run OpenSCAD CLI to generate both STL files
            const script = `#!/bin/bash
# OpenSCAD Auto-Render Script
# Generated: ${new Date().toISOString()}
# Seed: ${currentSeed}

SCAD_FILE="${scadFilename}"

echo "ðŸ”§ Starting OpenSCAD auto-render..."
echo ""

# Check if OpenSCAD is installed
if ! command -v openscad &> /dev/null; then
    echo "âŒ Error: OpenSCAD not found in PATH"
    echo "Please install OpenSCAD or add it to your PATH"
    echo "macOS: /Applications/OpenSCAD.app/Contents/MacOS/OpenSCAD"
    exit 1
fi

# Check if SCAD file exists
if [ ! -f "$SCAD_FILE" ]; then
    echo "âŒ Error: $SCAD_FILE not found"
    echo "Make sure the SCAD file is in the same directory as this script"
    exit 1
fi

echo "ðŸ“ Rendering FRAME structure..."
openscad -o "${frameFilename}" \\
    -D 'EXPORT_STRUCTURE=true' \\
    -D 'EXPORT_WASHERS=false' \\
    "$SCAD_FILE"

if [ $? -eq 0 ]; then
    echo "âœ… Frame exported: ${frameFilename}"
else
    echo "âŒ Frame rendering failed"
    exit 1
fi

echo ""
echo "ðŸ’ Rendering WASHER rings..."
openscad -o "${ringsFilename}" \\
    -D 'EXPORT_STRUCTURE=false' \\
    -D 'EXPORT_WASHERS=true' \\
    "$SCAD_FILE"

if [ $? -eq 0 ]; then
    echo "âœ… Rings exported: ${ringsFilename}"
else
    echo "âŒ Rings rendering failed"
    exit 1
fi

echo ""
echo "ðŸŽ‰ All STL files generated successfully!"
echo "   â€¢ ${frameFilename}"
echo "   â€¢ ${ringsFilename}"
`;

            // Download script file
            const blob = new Blob([script], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `render_${currentSeed}.sh`;
            link.click();
            URL.revokeObjectURL(url);

            console.log('OpenSCAD automation script exported');
        }

        function getBridgeAttachmentPointForSCAD(lens, position, legOffset) {
            switch(position) {
                case 'L':
                    return {
                        x: lens.position.x - (lens.radius - legOffset),
                        y: lens.position.y
                    };
                case 'C':
                    return {
                        x: lens.position.x,
                        y: lens.position.y + (lens.radius - legOffset)
                    };
                case 'R':
                    return {
                        x: lens.position.x + (lens.radius - legOffset),
                        y: lens.position.y
                    };
            }
        }

        function step() {
            // Try to add one ring
            const maxAttempts = 500;
            let placed = false;

            for (let attempt = 0; attempt < maxAttempts && !placed; attempt++) {
                attempts++;

                // Pick random anchor to be tangent to
                const anchor = anchors[Math.floor(rng() * anchors.length)];

                // Pick random radius with more variety
                // Use weighted distribution: favor medium sizes but allow extremes
                const r = rng();
                let radius;
                if (r < 0.15) {
                    // 15% small lenses (10-25mm)
                    radius = rng() * 15 + 10;
                } else if (r < 0.70) {
                    // 55% medium lenses (25-50mm)
                    radius = rng() * 25 + 25;
                } else if (r < 0.90) {
                    // 20% large lenses (50-75mm)
                    radius = rng() * 25 + 50;
                } else {
                    // 10% extra large lenses (75-100mm)
                    radius = rng() * 25 + 75;
                }

                // Pick second tangent target (another ring or anchor)
                const targets = [...rings, ...anchors.filter(a => a !== anchor)];

                if (targets.length === 0) {
                    // First ring - place tangent to anchor at random angle
                    const angle = rng() * Math.PI * 2;
                    const dist = anchor.radius + radius;
                    const x = anchor.x + Math.cos(angle) * dist;
                    const y = anchor.y + Math.sin(angle) * dist;

                    if (isValid({x, y, radius})) {
                        // Assign color from palette and leg type
                        const color = LENS_COLORS[rings.length % LENS_COLORS.length];
                        const legType = assignLegType(rng);
                        rings.push({x, y, radius, color, legType});
                        placed = true;
                    }
                } else {
                    // Solve for circle tangent to anchor AND another target
                    const target = targets[Math.floor(rng() * targets.length)];
                    const solution = solveTangentCircle(anchor, target, radius);

                    if (solution && isValid(solution)) {
                        // Assign color from palette and leg type
                        const color = LENS_COLORS[rings.length % LENS_COLORS.length];
                        const legType = assignLegType(rng);
                        solution.color = color;
                        solution.legType = legType;
                        rings.push(solution);
                        placed = true;
                    }
                }
            }

            draw();
            updateInfo();
        }

        // Strategy-specific step functions

        function stepLargeOnly() {
            // Sparse Giant strategy - only large lenses (50-90mm)
            const maxAttempts = 500;
            let placed = false;

            for (let attempt = 0; attempt < maxAttempts && !placed; attempt++) {
                attempts++;

                const anchor = anchors[Math.floor(rng() * anchors.length)];
                const radius = rng() * 40 + 50; // 50-90mm only - HUGE

                const targets = [...rings, ...anchors.filter(a => a !== anchor)];

                if (targets.length === 0) {
                    const angle = rng() * Math.PI * 2;
                    const dist = anchor.radius + radius;
                    const x = anchor.x + Math.cos(angle) * dist;
                    const y = anchor.y + Math.sin(angle) * dist;

                    if (isValid({x, y, radius})) {
                        const color = LENS_COLORS[rings.length % LENS_COLORS.length];
                        const legType = assignLegType(rng);
                        rings.push({x, y, radius, color, legType});
                        placed = true;
                    }
                } else {
                    const target = targets[Math.floor(rng() * targets.length)];
                    const solution = solveTangentCircle(anchor, target, radius);

                    if (solution && isValid(solution)) {
                        const color = LENS_COLORS[rings.length % LENS_COLORS.length];
                        const legType = assignLegType(rng);
                        solution.color = color;
                        solution.legType = legType;
                        rings.push(solution);
                        placed = true;
                    }
                }
            }
            // Don't draw/update on every step - wait until all lenses are placed
        }

        function stepSmallOnly() {
            // Micro Cluster strategy - only tiny lenses (10-25mm)
            const maxAttempts = 500;
            let placed = false;

            for (let attempt = 0; attempt < maxAttempts && !placed; attempt++) {
                attempts++;

                const anchor = anchors[Math.floor(rng() * anchors.length)];
                const radius = rng() * 15 + 10; // 10-25mm - small but packable

                const targets = [...rings, ...anchors.filter(a => a !== anchor)];

                if (targets.length === 0) {
                    const angle = rng() * Math.PI * 2;
                    const dist = anchor.radius + radius;
                    const x = anchor.x + Math.cos(angle) * dist;
                    const y = anchor.y + Math.sin(angle) * dist;

                    if (isValid({x, y, radius})) {
                        const color = LENS_COLORS[rings.length % LENS_COLORS.length];
                        const legType = assignLegType(rng);
                        rings.push({x, y, radius, color, legType});
                        placed = true;
                    }
                } else {
                    const target = targets[Math.floor(rng() * targets.length)];
                    const solution = solveTangentCircle(anchor, target, radius);

                    if (solution && isValid(solution)) {
                        const color = LENS_COLORS[rings.length % LENS_COLORS.length];
                        const legType = assignLegType(rng);
                        solution.color = color;
                        solution.legType = legType;
                        rings.push(solution);
                        placed = true;
                    }
                }
            }
        }

        function stepMaximal() {
            // Minimalist strategy - try progressively larger radii until one fits
            const maxAttempts = 100;
            let placed = false;

            // Try radii from large to small: 100mm down to 30mm
            for (let testRadius = 100; testRadius >= 30 && !placed; testRadius -= 5) {
                for (let attempt = 0; attempt < maxAttempts && !placed; attempt++) {
                    attempts++;

                    const anchor = anchors[Math.floor(rng() * anchors.length)];
                    const targets = [...rings, ...anchors.filter(a => a !== anchor)];

                    if (targets.length === 0) {
                        const angle = rng() * Math.PI * 2;
                        const dist = anchor.radius + testRadius;
                        const x = anchor.x + Math.cos(angle) * dist;
                        const y = anchor.y + Math.sin(angle) * dist;

                        if (isValid({x, y, radius: testRadius})) {
                            const color = LENS_COLORS[rings.length % LENS_COLORS.length];
                            const legType = assignLegType(rng);
                            rings.push({x, y, radius: testRadius, color, legType});
                            placed = true;
                        }
                    } else {
                        const target = targets[Math.floor(rng() * targets.length)];
                        const solution = solveTangentCircle(anchor, target, testRadius);

                        if (solution && isValid(solution)) {
                            const color = LENS_COLORS[rings.length % LENS_COLORS.length];
                            const legType = assignLegType(rng);
                            solution.color = color;
                            solution.legType = legType;
                            rings.push(solution);
                            placed = true;
                        }
                    }
                }
            }
        }

        function generateTwins(targetCount) {
            // Twins strategy - pick 2-3 radius values and repeat them
            const numSizes = Math.floor(rng() * 2) + 2; // 2-3 different sizes
            const sizes = [];

            // Pick distinct sizes
            for (let i = 0; i < numSizes; i++) {
                sizes.push(rng() * 50 + 20); // 20-70mm range
            }

            console.log('ðŸ‘¯ Twin sizes:', sizes.map(s => s.toFixed(1)));

            // Place lenses using only these sizes
            for (let i = 0; i < targetCount; i++) {
                const radius = sizes[i % sizes.length]; // Cycle through the twin sizes
                const maxAttempts = 500;
                let placed = false;

                for (let attempt = 0; attempt < maxAttempts && !placed; attempt++) {
                    attempts++;

                    const anchor = anchors[Math.floor(rng() * anchors.length)];
                    const targets = [...rings, ...anchors.filter(a => a !== anchor)];

                    if (targets.length === 0) {
                        const angle = rng() * Math.PI * 2;
                        const dist = anchor.radius + radius;
                        const x = anchor.x + Math.cos(angle) * dist;
                        const y = anchor.y + Math.sin(angle) * dist;

                        if (isValid({x, y, radius})) {
                            const color = LENS_COLORS[rings.length % LENS_COLORS.length];
                            const legType = assignLegType(rng);
                            rings.push({x, y, radius, color, legType});
                            placed = true;
                        }
                    } else {
                        const target = targets[Math.floor(rng() * targets.length)];
                        const solution = solveTangentCircle(anchor, target, radius);

                        if (solution && isValid(solution)) {
                            const color = LENS_COLORS[rings.length % LENS_COLORS.length];
                            const legType = assignLegType(rng);
                            solution.color = color;
                            solution.legType = legType;
                            rings.push(solution);
                            placed = true;
                        }
                    }
                }
            }
        }

        function generateApollonian(targetCount) {
            // Apollonian strategy - start with circle tangent to all 3 anchors, then nest

            // First, try to find circle tangent to all 3 anchors
            const baseCircle = findTriTangentCircle();

            if (baseCircle) {
                const color = LENS_COLORS[0];
                const legType = assignLegType(rng);
                rings.push({...baseCircle, color, legType});
                console.log('ðŸŽ¯ Apollonian base circle:', baseCircle.radius.toFixed(1) + 'mm');
            }

            // Then pack smaller circles in remaining space
            for (let i = rings.length; i < targetCount; i++) {
                step();
            }
        }

        function generateHalo(targetCount) {
            // Halo strategy - one giant lens as focal point + swarm of tiny lenses

            // Step 1: Place ONE giant lens (70-95mm)
            const giantRadius = rng() * 25 + 70; // 70-95mm - MASSIVE
            const maxAttempts = 200;
            let giantPlaced = false;

            for (let attempt = 0; attempt < maxAttempts && !giantPlaced; attempt++) {
                attempts++;

                // Try to place giant lens near center or tangent to one anchor
                const anchor = anchors[Math.floor(rng() * anchors.length)];

                // 50% chance: near center, 50% chance: tangent to anchor
                let x, y;
                if (rng() < 0.5) {
                    // Place near center with small offset
                    const offset = (rng() - 0.5) * 30; // Â±15mm from center
                    const angle = rng() * Math.PI * 2;
                    x = Math.cos(angle) * Math.abs(offset);
                    y = Math.sin(angle) * Math.abs(offset);
                } else {
                    // Place tangent to an anchor
                    const angle = rng() * Math.PI * 2;
                    const dist = anchor.radius + giantRadius;
                    x = anchor.x + Math.cos(angle) * dist;
                    y = anchor.y + Math.sin(angle) * dist;
                }

                if (isValid({x, y, radius: giantRadius})) {
                    const color = LENS_COLORS[0];
                    const legType = assignLegType(rng);
                    rings.push({x, y, radius: giantRadius, color, legType});
                    giantPlaced = true;
                    console.log(`â˜€ï¸ Halo giant lens: ${giantRadius.toFixed(1)}mm at (${x.toFixed(1)}, ${y.toFixed(1)})`);
                }
            }

            if (!giantPlaced) {
                console.log('âš ï¸ Halo: Could not place giant lens, trying smaller...');
                // Fallback: try a smaller giant
                for (let testRadius = 65; testRadius >= 40 && !giantPlaced; testRadius -= 5) {
                    for (let attempt = 0; attempt < 50 && !giantPlaced; attempt++) {
                        const anchor = anchors[Math.floor(rng() * anchors.length)];
                        const angle = rng() * Math.PI * 2;
                        const dist = anchor.radius + testRadius;
                        const x = anchor.x + Math.cos(angle) * dist;
                        const y = anchor.y + Math.sin(angle) * dist;

                        if (isValid({x, y, radius: testRadius})) {
                            const color = LENS_COLORS[0];
                            const legType = assignLegType(rng);
                            rings.push({x, y, radius: testRadius, color, legType});
                            giantPlaced = true;
                            console.log(`â˜€ï¸ Halo giant lens (fallback): ${testRadius}mm`);
                        }
                    }
                }
            }

            // Step 2: Fill remaining space with SWARM of tiny lenses (8-18mm)
            const remainingCount = targetCount - rings.length;
            let totalAttempts = 0;
            const maxTotalAttempts = remainingCount * 1000;

            while (rings.length < targetCount && totalAttempts < maxTotalAttempts) {
                const beforeCount = rings.length;
                stepTinySwarm(); // Use tiny lenses (8-18mm)
                totalAttempts += 500;

                if (rings.length === beforeCount) {
                    console.log(`âš ï¸ Halo stopped early: ${rings.length}/${targetCount} lenses (1 giant + ${rings.length - 1} tiny)`);
                    break;
                }
            }

            console.log(`âœ¨ Halo complete: ${rings.length} lenses (1 giant @ ${rings[0]?.radius.toFixed(1)}mm + ${rings.length - 1} tiny)`);
        }

        function stepTinySwarm() {
            // Ultra-tiny lenses for Halo swarm effect (8-18mm)
            const maxAttempts = 500;
            let placed = false;

            for (let attempt = 0; attempt < maxAttempts && !placed; attempt++) {
                attempts++;

                const anchor = anchors[Math.floor(rng() * anchors.length)];
                const radius = rng() * 10 + 8; // 8-18mm - EXTRA TINY for swarm

                const targets = [...rings, ...anchors.filter(a => a !== anchor)];

                if (targets.length === 0) {
                    const angle = rng() * Math.PI * 2;
                    const dist = anchor.radius + radius;
                    const x = anchor.x + Math.cos(angle) * dist;
                    const y = anchor.y + Math.sin(angle) * dist;

                    if (isValid({x, y, radius})) {
                        const color = LENS_COLORS[rings.length % LENS_COLORS.length];
                        const legType = assignLegType(rng);
                        rings.push({x, y, radius, color, legType});
                        placed = true;
                    }
                } else {
                    const target = targets[Math.floor(rng() * targets.length)];
                    const solution = solveTangentCircle(anchor, target, radius);

                    if (solution && isValid(solution)) {
                        const color = LENS_COLORS[rings.length % LENS_COLORS.length];
                        const legType = assignLegType(rng);
                        solution.color = color;
                        solution.legType = legType;
                        rings.push(solution);
                        placed = true;
                    }
                }
            }
        }

        function findTriTangentCircle() {
            // Find circle tangent to all 3 anchors (nestled between them)
            // This is the inner Soddy circle for 3 circles

            if (anchors.length < 3) return null;

            const [a1, a2, a3] = anchors;

            // Use Descartes Circle Theorem
            // For 3 mutually tangent circles with curvatures k1, k2, k3
            // The fourth tangent circle has curvature: k4 = k1 + k2 + k3 Â± 2âˆš(k1k2 + k2k3 + k3k1)

            const k1 = 1 / a1.radius;
            const k2 = 1 / a2.radius;
            const k3 = 1 / a3.radius;

            // We want the circle nestled BETWEEN the three anchors (positive curvature)
            const sum = k1 + k2 + k3;
            const products = k1*k2 + k2*k3 + k3*k1;
            const k4_inner = sum + 2 * Math.sqrt(products);

            const radius = 1 / k4_inner;

            // Now find the center position using Complex Descartes theorem
            // This is geometrically complex, so we'll use a simplified approach:
            // Try to solve for a circle tangent to all 3 anchors

            // Calculate center by solving tangency constraints
            // This requires solving a system of equations - for now, use approximation

            // Centroid of the three anchor positions
            const cx = (a1.x + a2.x + a3.x) / 3;
            const cy = (a1.y + a2.y + a3.y) / 3;

            // Check if this position with calculated radius is valid
            const candidate = {x: cx, y: cy, radius: radius};

            if (isValid(candidate) && radius > 5 && radius < 100) {
                return candidate;
            }

            return null;
        }

        function updateInfo() {
            document.getElementById('circle-count').textContent = rings.length;
            document.getElementById('attempts').textContent = attempts;
            document.getElementById('seed-display').textContent = currentSeed;
            const paletteKey = PALETTE_ORDER[currentPaletteIndex];
            document.getElementById('palette-name').textContent = COLOR_PALETTES[paletteKey].name;
            document.getElementById('strategy-name').textContent = STRATEGIES[currentStrategy].name;
        }

        function solveTangentCircle(c1, c2, radius) {
            // Solve for circle of given radius tangent to both c1 and c2
            // This is Apollonius' problem (CPP case - two circles, one point/radius)

            const dx = c2.x - c1.x;
            const dy = c2.y - c1.y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            // Distance from c1 center to new circle center
            const d1 = c1.radius + radius;
            // Distance from c2 center to new circle center
            const d2 = c2.radius + radius;

            // Check if solution is possible
            if (Math.abs(d1 - d2) > dist || d1 + d2 < dist) {
                return null;
            }

            // Using law of cosines to find angle
            const a = (d1 * d1 - d2 * d2 + dist * dist) / (2 * dist);
            const h = Math.sqrt(d1 * d1 - a * a);

            // Midpoint along line between centers
            const mx = c1.x + (dx / dist) * a;
            const my = c1.y + (dy / dist) * a;

            // Perpendicular offset
            const px = -dy / dist;
            const py = dx / dist;

            // Two solutions (pick one randomly)
            const sign = rng() < 0.5 ? 1 : -1;
            return {
                x: mx + px * h * sign,
                y: my + py * h * sign,
                radius: radius
            };
        }

        function isValid(circle) {
            // Check bounds
            if (Math.abs(circle.x) + circle.radius > BOUNDARY / 2) return false;
            if (Math.abs(circle.y) + circle.radius > BOUNDARY / 2) return false;

            // Strategy-specific constraints
            const strategy = STRATEGIES[currentStrategy];
            if (strategy.constraint === 'upper_half') {
                // Top-Heavy: only allow lenses in upper half (y < 0)
                if (circle.y > 0) return false;
            } else if (strategy.constraint === 'lower_half') {
                // Bottom-Heavy: only allow lenses in lower half (y > 0)
                if (circle.y < 0) return false;
            } else if (strategy.constraint === 'ring') {
                // Ring Formation: no lenses within 30mm of center
                const distFromCenter = Math.sqrt(circle.x * circle.x + circle.y * circle.y);
                if (distFromCenter < 30) return false;
            }

            // Check no overlap with existing rings
            for (const ring of rings) {
                const dx = circle.x - ring.x;
                const dy = circle.y - ring.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < circle.radius + ring.radius - 1) { // -1mm tolerance
                    return false;
                }
            }

            // Check no overlap with anchors (except tangency)
            for (const anchor of anchors) {
                const dx = circle.x - anchor.x;
                const dy = circle.y - anchor.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const expectedDist = circle.radius + anchor.radius;
                // Allow tangency (within 2mm) but not overlap
                if (dist < circle.radius + anchor.radius - 2 && Math.abs(dist - expectedDist) > 2) {
                    return false;
                }
            }

            return true;
        }

        function draw() {
            // Clear with white
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw 152mm Ã— 152mm workspace boundary (10% gray)
            const workspaceSize = BOUNDARY * SCALE; // 152mm Ã— 3.5 = 532px
            const workspaceX = CENTER_X - (workspaceSize / 2);
            const workspaceY = CENTER_Y - (workspaceSize / 2);
            ctx.fillStyle = 'rgba(0, 0, 0, 0.10)'; // 10% gray
            ctx.fillRect(workspaceX, workspaceY, workspaceSize, workspaceSize);

            // Draw ground plane guide (soft gray, not exported)
            const groundY = CENTER_Y + (BOUNDARY / 2) * SCALE;
            ctx.strokeStyle = '#cccccc';
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(0, groundY);
            ctx.lineTo(canvas.width, groundY);
            ctx.stroke();
            ctx.setLineDash([]); // Reset dash

            // Draw ground plane label
            ctx.fillStyle = '#999999';
            ctx.font = '12px Courier New';
            ctx.textAlign = 'left';
            ctx.fillText('GROUND PLANE (Y=+76mm)', 10, groundY - 5);

            // Draw center axes (soft gray, not exported)
            ctx.strokeStyle = '#dddddd';
            ctx.lineWidth = 1;
            ctx.setLineDash([3, 3]);

            // Vertical axis (Y-axis)
            ctx.beginPath();
            ctx.moveTo(CENTER_X, 0);
            ctx.lineTo(CENTER_X, canvas.height);
            ctx.stroke();

            // Horizontal axis (X-axis)
            ctx.beginPath();
            ctx.moveTo(0, CENTER_Y);
            ctx.lineTo(canvas.width, CENTER_Y);
            ctx.stroke();

            ctx.setLineDash([]); // Reset dash

            // Draw axis labels
            ctx.fillStyle = '#aaaaaa';
            ctx.font = '11px Courier New';
            ctx.textAlign = 'center';
            ctx.fillText('X=0', CENTER_X, CENTER_Y - 5);
            ctx.textAlign = 'left';
            ctx.fillText('Y=0', CENTER_X + 5, CENTER_Y + 12);

            // Draw legs (if enabled)
            const showLegs = document.getElementById('showLegs').checked;
            if (showLegs) {
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = LEG_THICKNESS * SCALE; // 1.2mm legs

                rings.forEach(ring => {
                    const cx = CENTER_X + ring.x * SCALE;
                    const cy = CENTER_Y + ring.y * SCALE;
                    const r = ring.radius * SCALE;
                    const legOffset = 0.6; // mm - half of frame outer ring width (1.2mm / 2)
                    const groundY = CENTER_Y + (BOUNDARY / 2) * SCALE;

                    switch(ring.legType) {
                        case 'none':
                            // No legs
                            break;

                        case 'single':
                            // Single straight leg from center bottom (offset inward)
                            const singleY = cy + (ring.radius - legOffset) * SCALE;
                            ctx.beginPath();
                            ctx.moveTo(cx, singleY);
                            ctx.lineTo(cx, groundY);
                            ctx.stroke();
                            break;

                        case 'double':
                            // Two straight legs from left and right (offset inward)
                            const doubleLeftX = cx - (ring.radius - legOffset) * SCALE;
                            const doubleRightX = cx + (ring.radius - legOffset) * SCALE;

                            ctx.beginPath();
                            ctx.moveTo(doubleLeftX, cy);
                            ctx.lineTo(doubleLeftX, groundY);
                            ctx.stroke();

                            ctx.beginPath();
                            ctx.moveTo(doubleRightX, cy);
                            ctx.lineTo(doubleRightX, groundY);
                            ctx.stroke();
                            break;

                        case 'left_only':
                            // Single straight leg from left edge only
                            const leftOnlyX = cx - (ring.radius - legOffset) * SCALE;
                            ctx.beginPath();
                            ctx.moveTo(leftOnlyX, cy);
                            ctx.lineTo(leftOnlyX, groundY);
                            ctx.stroke();
                            break;

                        case 'right_only':
                            // Single straight leg from right edge only
                            const rightOnlyX = cx + (ring.radius - legOffset) * SCALE;
                            ctx.beginPath();
                            ctx.moveTo(rightOnlyX, cy);
                            ctx.lineTo(rightOnlyX, groundY);
                            ctx.stroke();
                            break;

                        case 'curved_lc':
                            // Left-center U-shaped leg
                            // Vertical leg from left edge (offset inward by 0.6mm)
                            const leftEdgeX1 = cx - (ring.radius - legOffset) * SCALE;
                            const leftEdgeY1 = cy;

                            // Vertical leg from center bottom (offset inward by 0.6mm)
                            const centerBottomX1 = cx;
                            const centerBottomY1 = cy + (ring.radius - legOffset) * SCALE;

                            // Arc radius for the U-shape bottom
                            const arcRadius1 = (centerBottomX1 - leftEdgeX1) / 2;
                            const arcCenterX1 = leftEdgeX1 + arcRadius1;
                            const arcCenterY1 = groundY - arcRadius1;

                            // Only draw if arc center is below ring
                            if (arcCenterY1 > cy + r) {
                                // Draw left vertical
                                ctx.beginPath();
                                ctx.moveTo(leftEdgeX1, leftEdgeY1);
                                ctx.lineTo(leftEdgeX1, arcCenterY1);
                                ctx.stroke();

                                // Draw right vertical
                                ctx.beginPath();
                                ctx.moveTo(centerBottomX1, centerBottomY1);
                                ctx.lineTo(centerBottomX1, arcCenterY1);
                                ctx.stroke();

                                // Draw U-shaped arc at bottom
                                ctx.beginPath();
                                ctx.arc(arcCenterX1, arcCenterY1, arcRadius1, 0, Math.PI, false);
                                ctx.stroke();
                            }
                            break;

                        case 'curved_cr':
                            // Center-right U-shaped leg
                            // Vertical leg from center bottom (offset inward by 0.6mm)
                            const centerBottomX2 = cx;
                            const centerBottomY2 = cy + (ring.radius - legOffset) * SCALE;

                            // Vertical leg from right edge (offset inward by 0.6mm)
                            const rightEdgeX2 = cx + (ring.radius - legOffset) * SCALE;
                            const rightEdgeY2 = cy;

                            // Arc radius for the U-shape bottom
                            const arcRadius2 = (rightEdgeX2 - centerBottomX2) / 2;
                            const arcCenterX2 = centerBottomX2 + arcRadius2;
                            const arcCenterY2 = groundY - arcRadius2;

                            // Only draw if arc center is below ring
                            if (arcCenterY2 > cy + r) {
                                // Draw left vertical
                                ctx.beginPath();
                                ctx.moveTo(centerBottomX2, centerBottomY2);
                                ctx.lineTo(centerBottomX2, arcCenterY2);
                                ctx.stroke();

                                // Draw right vertical
                                ctx.beginPath();
                                ctx.moveTo(rightEdgeX2, rightEdgeY2);
                                ctx.lineTo(rightEdgeX2, arcCenterY2);
                                ctx.stroke();

                                // Draw U-shaped arc at bottom
                                ctx.beginPath();
                                ctx.arc(arcCenterX2, arcCenterY2, arcRadius2, 0, Math.PI, false);
                                ctx.stroke();
                            }
                            break;

                        case 'curved_lr':
                            // Left-right wide U-shaped leg
                            // Vertical leg from left edge (offset inward by 0.6mm)
                            const leftEdgeX3 = cx - (ring.radius - legOffset) * SCALE;
                            const leftEdgeY3 = cy;

                            // Vertical leg from right edge (offset inward by 0.6mm)
                            const rightEdgeX3 = cx + (ring.radius - legOffset) * SCALE;
                            const rightEdgeY3 = cy;

                            // Arc radius for the wide U-shape bottom
                            const arcRadius3 = (rightEdgeX3 - leftEdgeX3) / 2;
                            const arcCenterX3 = cx;
                            const arcCenterY3 = groundY - arcRadius3;

                            // Only draw if arc center is below ring
                            if (arcCenterY3 > cy + r) {
                                // Draw left vertical
                                ctx.beginPath();
                                ctx.moveTo(leftEdgeX3, leftEdgeY3);
                                ctx.lineTo(leftEdgeX3, arcCenterY3);
                                ctx.stroke();

                                // Draw right vertical
                                ctx.beginPath();
                                ctx.moveTo(rightEdgeX3, rightEdgeY3);
                                ctx.lineTo(rightEdgeX3, arcCenterY3);
                                ctx.stroke();

                                // Draw U-shaped arc at bottom
                                ctx.beginPath();
                                ctx.arc(arcCenterX3, arcCenterY3, arcRadius3, 0, Math.PI, false);
                                ctx.stroke();
                            }
                            break;

                        case 'curved_adjacent':
                            // Bridge leg connecting two adjacent (tangent) lenses
                            if (ring.adjacentRingIndex !== -1 && ring.adjacentRingIndex < rings.length) {
                                const adjacent = rings[ring.adjacentRingIndex];

                                // Calculate tangent point between the two circles
                                const dx = adjacent.x - ring.x;
                                const dy = adjacent.y - ring.y;
                                const dist = Math.sqrt(dx * dx + dy * dy);

                                // Tangent point is along the line connecting centers
                                // At distance r1 from center1
                                const tangentX = ring.x + (dx / dist) * ring.radius;
                                const tangentY = ring.y + (dy / dist) * ring.radius;

                                // Convert to canvas coordinates
                                const tangentCanvasX = CENTER_X + tangentX * SCALE;
                                const tangentCanvasY = CENTER_Y + tangentY * SCALE;

                                // Draw two vertical legs from the tangent point
                                const legSpacing = 3 * SCALE; // 3mm apart
                                const leg1X = tangentCanvasX - legSpacing / 2;
                                const leg2X = tangentCanvasX + legSpacing / 2;

                                // Arc radius for the bridge
                                const bridgeArcRadius = legSpacing / 2;
                                const bridgeArcCenterX = tangentCanvasX;
                                const bridgeArcCenterY = groundY - bridgeArcRadius;

                                // Only draw if arc center is below both rings
                                const ring1Bottom = cy + r;
                                const adjacent_cy = CENTER_Y + adjacent.y * SCALE;
                                const adjacent_r = adjacent.radius * SCALE;
                                const ring2Bottom = adjacent_cy + adjacent_r;

                                if (bridgeArcCenterY > ring1Bottom && bridgeArcCenterY > ring2Bottom) {
                                    // Draw left vertical leg
                                    ctx.beginPath();
                                    ctx.moveTo(leg1X, tangentCanvasY);
                                    ctx.lineTo(leg1X, bridgeArcCenterY);
                                    ctx.stroke();

                                    // Draw right vertical leg
                                    ctx.beginPath();
                                    ctx.moveTo(leg2X, tangentCanvasY);
                                    ctx.lineTo(leg2X, bridgeArcCenterY);
                                    ctx.stroke();

                                    // Draw U-shaped arc at bottom
                                    ctx.beginPath();
                                    ctx.arc(bridgeArcCenterX, bridgeArcCenterY, bridgeArcRadius, 0, Math.PI, false);
                                    ctx.stroke();
                                }
                            }
                            break;
                    }
                });
            }

            // Draw bridges
            if (bridges && bridges.length > 0) {
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 1.2 * SCALE;
                ctx.lineCap = 'butt';

                const legOffset = 0.6; // mm
                const groundY = CENTER_Y + (BOUNDARY / 2) * SCALE;

                bridges.forEach((bridge, bridgeIndex) => {
                    const lens1 = rings[bridge.lens1Index];
                    const lens2 = rings[bridge.lens2Index];

                    // Safety check: skip if lenses don't exist
                    if (!lens1 || !lens2) return;

                    // Get attachment points for lens 1
                    const {x: x1, y: y1} = getBridgeAttachmentPoint(lens1, bridge.lens1Position, legOffset);
                    // Get attachment points for lens 2
                    const {x: x2, y: y2} = getBridgeAttachmentPoint(lens2, bridge.lens2Position, legOffset);

                    // Convert to canvas coordinates
                    const canvasX1 = CENTER_X + x1 * SCALE;
                    const canvasY1 = CENTER_Y + y1 * SCALE;
                    const canvasX2 = CENTER_X + x2 * SCALE;
                    const canvasY2 = CENTER_Y + y2 * SCALE;

                    // Calculate arc parameters
                    const arcRadius = Math.abs(canvasX2 - canvasX1) / 2;
                    const arcCenterX = (canvasX1 + canvasX2) / 2;
                    const arcCenterY = groundY - arcRadius;

                    // Only draw if arc center is below both lenses
                    const lens1Bottom = CENTER_Y + (lens1.y + lens1.radius) * SCALE;
                    const lens2Bottom = CENTER_Y + (lens2.y + lens2.radius) * SCALE;

                    if (arcCenterY > lens1Bottom && arcCenterY > lens2Bottom) {
                        // Draw vertical leg 1
                        ctx.beginPath();
                        ctx.moveTo(canvasX1, canvasY1);
                        ctx.lineTo(canvasX1, arcCenterY);
                        ctx.stroke();

                        // Draw vertical leg 2
                        ctx.beginPath();
                        ctx.moveTo(canvasX2, canvasY2);
                        ctx.lineTo(canvasX2, arcCenterY);
                        ctx.stroke();

                        // Draw arc connecting them
                        ctx.beginPath();
                        if (canvasX1 < canvasX2) {
                            ctx.arc(arcCenterX, arcCenterY, arcRadius, 0, Math.PI, false);
                        } else {
                            ctx.arc(arcCenterX, arcCenterY, arcRadius, Math.PI, 0, true);
                        }
                        ctx.stroke();
                    }
                });
            }

            // Draw rings with frame structure
            const showColors = document.getElementById('showColors').checked;
            const stealthMode = document.getElementById('stealthMode').checked;
            const overlapZone = 0.5; // mm - suggested overlap for boolean union

            rings.forEach(ring => {
                const cx = CENTER_X + ring.x * SCALE;
                const cy = CENTER_Y + ring.y * SCALE;
                const r = ring.radius * SCALE;
                const frameWidth = 1.2; // mm - each part of frame
                const outerFrameRadius = r; // Outer edge
                const channelRadius = (ring.radius - frameWidth) * SCALE; // Channel ledge
                const innerRadius = (ring.radius - LENS_THICKNESS) * SCALE; // Inner clear area
                const overlapRadius = (ring.radius + overlapZone) * SCALE; // Overlap zone

                if (stealthMode) {
                    // Stealth mode - grayscale lenses, black everything else
                    // Fill inner area with grayscale
                    const grayValue = Math.floor(128 + Math.random() * 64); // Random gray 128-192
                    ctx.fillStyle = `rgb(${grayValue}, ${grayValue}, ${grayValue})`;
                    ctx.beginPath();
                    ctx.arc(cx, cy, innerRadius, 0, Math.PI * 2);
                    ctx.fill();

                    // Draw outer frame ring (black)
                    ctx.fillStyle = '#000000';
                    ctx.beginPath();
                    ctx.arc(cx, cy, outerFrameRadius, 0, Math.PI * 2);
                    ctx.arc(cx, cy, channelRadius, 0, Math.PI * 2, true);
                    ctx.fill();

                    // Draw channel ring (black instead of red)
                    ctx.fillStyle = '#000000';
                    ctx.beginPath();
                    ctx.arc(cx, cy, channelRadius, 0, Math.PI * 2);
                    ctx.arc(cx, cy, innerRadius, 0, Math.PI * 2, true);
                    ctx.fill();
                } else if (showColors) {
                    // Fill inner area with lens color
                    ctx.fillStyle = ring.color;
                    ctx.beginPath();
                    ctx.arc(cx, cy, innerRadius, 0, Math.PI * 2);
                    ctx.fill();

                    // Draw outer frame ring (black) - from outer edge to channel
                    ctx.fillStyle = '#000000';
                    ctx.beginPath();
                    ctx.arc(cx, cy, outerFrameRadius, 0, Math.PI * 2);
                    ctx.arc(cx, cy, channelRadius, 0, Math.PI * 2, true); // Counter-clockwise for hole
                    ctx.fill();

                    // Draw channel ring (black instead of red) - from channel to inner
                    ctx.fillStyle = '#000000';
                    ctx.beginPath();
                    ctx.arc(cx, cy, channelRadius, 0, Math.PI * 2);
                    ctx.arc(cx, cy, innerRadius, 0, Math.PI * 2, true); // Counter-clockwise for hole
                    ctx.fill();
                } else {
                    // Monochrome mode - draw frame structure in greyscale
                    // Outer frame ring (black)
                    ctx.fillStyle = '#000000';
                    ctx.beginPath();
                    ctx.arc(cx, cy, outerFrameRadius, 0, Math.PI * 2);
                    ctx.arc(cx, cy, channelRadius, 0, Math.PI * 2, true);
                    ctx.fill();

                    // Channel ring (red)
                    ctx.fillStyle = '#ff4444';
                    ctx.beginPath();
                    ctx.arc(cx, cy, channelRadius, 0, Math.PI * 2);
                    ctx.arc(cx, cy, innerRadius, 0, Math.PI * 2, true);
                    ctx.fill();

                    // Outline for visibility
                    ctx.strokeStyle = '#00ff00';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.arc(cx, cy, outerFrameRadius, 0, Math.PI * 2);
                    ctx.stroke();
                }

                // Highlight selected lens
                if (selectedLens === ring) {
                    ctx.strokeStyle = '#ff00ff'; // Magenta highlight
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(cx, cy, outerFrameRadius + 2, 0, Math.PI * 2);
                    ctx.stroke();
                }
            });

            // Draw anchor points (on top) - 6.36mm circle with 2.8mm square hole
            anchors.forEach((anchor, i) => {
                const x = CENTER_X + anchor.x * SCALE;
                const y = CENTER_Y + anchor.y * SCALE;
                const outerRadius = (ANCHOR_DIAMETER / 2) * SCALE;
                const holeSize = ANCHOR_HOLE_SIZE * SCALE;
                const overlapZone = 0.5; // mm - suggested overlap for boolean union

                // Draw outer circle (black)
                ctx.fillStyle = '#000000';
                ctx.beginPath();
                ctx.arc(x, y, outerRadius, 0, Math.PI * 2);
                ctx.fill();

                // Cut out square hole in center
                ctx.fillStyle = stealthMode ? '#000000' : '#ffffff';
                ctx.fillRect(
                    x - holeSize / 2,
                    y - holeSize / 2,
                    holeSize,
                    holeSize
                );

                // Stroke square hole for visibility
                ctx.strokeStyle = '#666666';
                ctx.lineWidth = 0.5;
                ctx.strokeRect(
                    x - holeSize / 2,
                    y - holeSize / 2,
                    holeSize,
                    holeSize
                );
            });
        }

        // Initial generation
        generate();
        updateInfo();

        // Mouse interaction for dragging anchors
        function getMousePos(e) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: (e.clientX - rect.left - CENTER_X) / SCALE,
                y: (e.clientY - rect.top - CENTER_Y) / SCALE
            };
        }

        function findAnchorAtPoint(x, y) {
            const clickRadius = 10; // pixels
            for (let anchor of anchors) {
                const dx = (x - anchor.x) * SCALE;
                const dy = (y - anchor.y) * SCALE;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < clickRadius) {
                    return anchor;
                }
            }
            return null;
        }

        function findLensAtPoint(x, y) {
            // Check if click is inside any lens
            for (let ring of rings) {
                const dx = x - ring.x;
                const dy = y - ring.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < ring.radius) {
                    return ring;
                }
            }
            return null;
        }

        canvas.addEventListener('mousedown', (e) => {
            const pos = getMousePos(e);

            // Check for anchor drag first (higher priority)
            draggedAnchor = findAnchorAtPoint(pos.x, pos.y);
            if (draggedAnchor) {
                isDragging = true;
                canvas.style.cursor = 'grabbing';
                selectedLens = null; // Deselect lens when dragging anchor
            } else {
                // Check for lens selection
                selectedLens = findLensAtPoint(pos.x, pos.y);
                if (selectedLens) {
                    draw(); // Redraw to show selection
                }
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            const pos = getMousePos(e);

            if (isDragging && draggedAnchor) {
                // Update anchor position
                draggedAnchor.x = pos.x;
                draggedAnchor.y = pos.y;

                // Clear bridges BEFORE regenerating rings to prevent draw() errors
                bridges = [];

                // Regenerate rings with new anchor positions
                rings = [];
                attempts = 0;
                rng = seededRandom(currentSeed);
                for (let i = 0; i < 10; i++) {
                    step();
                }

                // Regenerate legs and bridges for new ring positions
                regenerateLegs();
            } else {
                // Update cursor based on hover
                const hoverAnchor = findAnchorAtPoint(pos.x, pos.y);
                canvas.style.cursor = hoverAnchor ? 'grab' : 'default';
            }
        });

        canvas.addEventListener('mouseup', () => {
            isDragging = false;
            draggedAnchor = null;
            canvas.style.cursor = 'default';
        });

        canvas.addEventListener('mouseleave', () => {
            isDragging = false;
            draggedAnchor = null;
            canvas.style.cursor = 'default';
        });

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                e.preventDefault();
                generate();
            } else if (e.code === 'Enter') {
                e.preventDefault();
                step();
            } else if (e.code === 'KeyK') {
                // K for Knife - remove legs from selected lens
                e.preventDefault();
                if (selectedLens) {
                    selectedLens.legType = 'none';

                    // Clear occupied points for this lens
                    const lensIndex = rings.indexOf(selectedLens);
                    if (lensIndex !== -1 && occupiedPoints[lensIndex]) {
                        occupiedPoints[lensIndex].clear();
                    }

                    console.log('Removed legs from selected lens');
                    draw();
                }
            } else if (e.code === 'KeyR') {
                // R for Re-roll - cycle to next leg type
                e.preventDefault();
                if (selectedLens) {
                    const legTypes = ['none', 'single', 'double', 'left_only', 'right_only', 'curved_lc', 'curved_cr', 'curved_lr', 'curved_adjacent'];
                    const currentIndex = legTypes.indexOf(selectedLens.legType);
                    const nextIndex = (currentIndex + 1) % legTypes.length;
                    selectedLens.legType = legTypes[nextIndex];

                    // Update occupied points for this lens
                    const lensIndex = rings.indexOf(selectedLens);
                    if (lensIndex !== -1) {
                        if (!occupiedPoints[lensIndex]) {
                            occupiedPoints[lensIndex] = new Set();
                        } else {
                            occupiedPoints[lensIndex].clear();
                        }
                        markAttachmentPoints(lensIndex, selectedLens.legType);
                    }

                    console.log(`Changed leg type to: ${selectedLens.legType}`);
                    draw();
                }
            } else if (e.code === 'KeyD') {
                // D for Delete - remove selected lens
                e.preventDefault();
                if (selectedLens) {
                    rings = rings.filter(ring => ring !== selectedLens);
                    selectedLens = null;
                    console.log('Deleted lens');
                    updateInfo();
                    draw();
                }
            } else if (e.code === 'KeyA') {
                // A for Add - add new tangent lens
                e.preventDefault();

                // Pick random target (anchor or existing lens)
                const allTargets = [...anchors, ...rings];
                if (allTargets.length === 0) return;

                const target = allTargets[Math.floor(Math.random() * allTargets.length)];

                // Random radius in medium range (20-40mm)
                const newRadius = Math.random() * 20 + 20;

                // Try to find tangent position
                const maxAttempts = 100;
                for (let attempt = 0; attempt < maxAttempts; attempt++) {
                    // Pick second target for tangency (prefer anchors/rings, not the same as first)
                    let secondTarget = target;
                    if (allTargets.length > 1) {
                        const otherTargets = allTargets.filter(t => t !== target);
                        secondTarget = otherTargets[Math.floor(Math.random() * otherTargets.length)];
                    }

                    // Calculate tangent circle
                    const newCircle = solveTangentCircle(target, secondTarget, newRadius);

                    if (newCircle && isValid(newCircle)) {
                        // Success! Add the new lens
                        newCircle.color = LENS_COLORS[rings.length % LENS_COLORS.length];
                        newCircle.legType = 'none'; // Start with no legs
                        rings.push(newCircle);
                        selectedLens = newCircle;
                        console.log('Added new lens');
                        updateInfo();
                        draw();
                        break;
                    }
                }
            } else if (e.code === 'KeyN') {
                // N for regeNerate lenses
                e.preventDefault();
                regenerateLenses();
            } else if (e.code === 'KeyZ') {
                // Z for cycle strategy
                e.preventDefault();
                cycleStrategy();
            } else if (e.code === 'KeyM') {
                // M for reMake legs
                e.preventDefault();
                regenerateLegs();
            } else if (e.code === 'KeyP') {
                // P for Palette - cycle color palette
                e.preventDefault();
                cyclePalette();
            } else if (e.code === 'KeyL') {
                e.preventDefault();
                document.getElementById('showLegs').checked = !document.getElementById('showLegs').checked;
                draw();
            } else if (e.code === 'KeyC') {
                e.preventDefault();
                document.getElementById('showColors').checked = !document.getElementById('showColors').checked;
                draw();
            }
        });
    </script>
</body>
</html>
