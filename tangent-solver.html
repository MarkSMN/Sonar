<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Sonar - Tangent Circle Solver</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Courier New', Courier, monospace;
            overflow: hidden;
            display: flex;
            height: 100vh;
            background: #000000;
        }
        #canvas-container {
            flex: 1;
            background: #ffffff;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }
        #canvas {
            background: #ffffff;
            display: block;
        }
        #sidebar {
            width: 300px;
            background: #1a1a1a;
            color: #cccccc;
            display: flex;
            flex-direction: column;
            padding: 20px;
            overflow-y: auto;
        }
        #sidebar h1 {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 20px;
            letter-spacing: 1px;
            color: #ffffff;
        }
        .section {
            margin-bottom: 20px;
        }
        .section-title {
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1.2px;
            margin-bottom: 10px;
            color: #888888;
        }
        .info-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 6px;
            font-size: 12px;
        }
        .info-label {
            color: #888888;
        }
        .info-value {
            color: #cccccc;
            font-weight: 500;
            font-family: monospace;
        }
        button {
            background: #2a2a2a;
            color: #cccccc;
            border: none;
            border-radius: 6px;
            padding: 8px 12px;
            margin-bottom: 6px;
            cursor: pointer;
            font-family: 'Courier New', Courier, monospace;
            font-size: 12px;
            font-weight: 500;
            transition: background 0.2s;
            width: 100%;
            text-align: left;
        }
        button:hover {
            background: #333333;
            color: #ffffff;
        }
        button:active {
            background: #3a3a3a;
        }
        label {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            font-size: 12px;
            font-weight: 400;
            cursor: pointer;
            color: #cccccc;
        }
        input[type="checkbox"] {
            margin-right: 8px;
            width: 16px;
            height: 16px;
            cursor: pointer;
            accent-color: #666666;
        }
    </style>
</head>
<body>
    <div id="canvas-container">
        <canvas id="canvas" width="1200" height="900"></canvas>
    </div>

    <div id="sidebar">
        <h1>SONAR</h1>

        <div class="section">
            <div class="section-title">Instructions</div>
            <div style="font-size: 12px; line-height: 1.6; color: #999999;">
                <p style="margin-bottom: 8px;">Drag anchors to adjust triangulation</p>
                <p style="margin-bottom: 8px;">A: Add random tangent lens</p>
                <p style="margin-bottom: 8px;">Click lens + D: Delete lens</p>
                <p style="margin-bottom: 8px;">Click lens + K: Remove legs</p>
                <p style="margin-bottom: 8px;">Click lens + R: Cycle leg type</p>
                <p style="margin-bottom: 8px;">Space: New composition</p>
                <p style="margin-bottom: 8px;">N: Regenerate lenses</p>
                <p style="margin-bottom: 8px;">M: Regenerate legs</p>
                <p style="margin-bottom: 8px;">P: Cycle color palette</p>
                <p style="margin-bottom: 8px;">L: Toggle legs</p>
                <p>C: Toggle colors</p>
            </div>
        </div>

        <div class="section">
            <div class="section-title">Export</div>
            <button onclick="exportJSON()">Save JSON</button>
            <button onclick="exportPNG()">Save PNG</button>
        </div>

        <div class="section">
            <div class="section-title">Display</div>
            <label>
                <input type="checkbox" id="showLegs" checked onchange="draw()">
                Show Legs
            </label>
            <label>
                <input type="checkbox" id="showColors" checked onchange="draw()">
                Colored Lenses
            </label>
            <label>
                <input type="checkbox" id="stealthMode" onchange="draw()">
                Stealth Mode
            </label>
        </div>

        <div class="section">
            <div class="section-title">Composition Info</div>
            <div class="info-row">
                <span class="info-label">Rings</span>
                <span class="info-value" id="circle-count">0</span>
            </div>
            <div class="info-row">
                <span class="info-label">Attempts</span>
                <span class="info-value" id="attempts">0</span>
            </div>
            <div class="info-row">
                <span class="info-label">Palette</span>
                <span class="info-value" id="palette-name">Full Range</span>
            </div>
            <div class="info-row">
                <span class="info-label">Seed</span>
                <span class="info-value" id="seed-display">-</span>
            </div>
        </div>

        <div class="section">
            <div class="section-title">Specifications</div>
            <div class="info-row">
                <span class="info-label">Leg Thickness</span>
                <span class="info-value">1.2mm</span>
            </div>
            <div class="info-row">
                <span class="info-label">Lens Thickness</span>
                <span class="info-value">2.4mm</span>
            </div>
            <div class="info-row">
                <span class="info-label">Anchor Diameter</span>
                <span class="info-value">6.36mm</span>
            </div>
            <div class="info-row">
                <span class="info-label">Max Leg Count</span>
                <span class="info-value">5</span>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // Real-world dimensions in mm
        const LEG_THICKNESS = 1.2;      // mm
        const LENS_THICKNESS = 2.4;     // mm (ring frame)
        const ANCHOR_DIAMETER = 6.36;   // mm (circle diameter)
        const ANCHOR_HOLE_SIZE = 2.8;   // mm (square hole)

        // Scale for display
        const SCALE = 3.5;
        const CENTER_X = canvas.width / 2;
        const CENTER_Y = canvas.height / 2;
        const BOUNDARY = 220;           // mm (work area)

        // User-adjustable parameters
        let MAX_LENS_COUNT = 12;
        let MAX_LEG_COUNT = 5;

        let anchors = [];
        let rings = [];
        let attempts = 0;
        let currentSeed = Date.now();
        let lensSeed = Date.now();
        let legSeed = Date.now();

        // Dragging state
        let draggedAnchor = null;
        let isDragging = false;

        // Selected lens for leg editing
        let selectedLens = null;

        // Color palettes for lenses
        const COLOR_PALETTES = {
            'full_range': {
                name: 'Full Range',
                colors: ['#F4E8A0', '#E8C5A0', '#E8C4D5', '#A0B0E8', '#C4A0E8', '#999999']
            },
            'light_triad': {
                name: 'Light Value Triad',
                colors: ['#F4E8A0', '#E8C5A0', '#E8C4D5']
            },
            'dark_triad': {
                name: 'Dark Value Triad',
                colors: ['#A0B0E8', '#C4A0E8', '#999999']
            },
            'yellow_blue': {
                name: 'Yellow + Blue (Green Mix)',
                colors: ['#F4E8A0', '#A0B0E8']
            },
            'unique_triad': {
                name: 'Unique Triad',
                colors: ['#F4E8A0', '#C4A0E8', '#999999']
            },
            'yellow_mono': {
                name: 'Monochrome Yellow',
                colors: ['#F4E8A0']
            },
            'orange_mono': {
                name: 'Monochrome Orange',
                colors: ['#E8C5A0']
            },
            'pink_mono': {
                name: 'Monochrome Pink',
                colors: ['#E8C4D5']
            },
            'blue_mono': {
                name: 'Monochrome Blue',
                colors: ['#A0B0E8']
            },
            'purple_mono': {
                name: 'Monochrome Purple',
                colors: ['#C4A0E8']
            },
            'black_mono': {
                name: 'Monochrome Black',
                colors: ['#999999']
            },
            'warm_triad': {
                name: 'Warm Triad (with Red)',
                colors: ['#F4E8A0', '#E8C5A0', '#E89090']
            }
        };

        const PALETTE_ORDER = [
            'full_range',
            'light_triad',
            'dark_triad',
            'yellow_blue',
            'unique_triad',
            'yellow_mono',
            'orange_mono',
            'pink_mono',
            'blue_mono',
            'purple_mono',
            'black_mono',
            'warm_triad'
        ];

        let currentPaletteIndex = 0;
        let LENS_COLORS = COLOR_PALETTES[PALETTE_ORDER[currentPaletteIndex]].colors;

        // Seeded random
        function seededRandom(seed) {
            let state = seed;
            return function() {
                state = (state * 9301 + 49297) % 233280;
                return state / 233280;
            };
        }

        let rng = seededRandom(currentSeed);

        // Leg type assignment with probability distribution
        function assignLegType(rng) {
            const r = rng();
            if (r < 0.30) return 'single';        // 30% single straight
            if (r < 0.60) return 'double';        // 30% double straight
            if (r < 0.68) return 'curved_lc';     // 8% curved left-center
            if (r < 0.76) return 'curved_cr';     // 8% curved center-right
            if (r < 0.83) return 'curved_lr';     // 7% curved left-right
            if (r < 0.93) return 'curved_adjacent'; // 10% curved adjacent bridge
            return 'none';                        // 7% no legs
        }

        // Regenerate lenses while keeping anchors static
        function regenerateLenses() {
            if (anchors.length === 0) return;

            // Generate new lens seed
            lensSeed = Date.now();
            legSeed = Date.now();

            // Use lensSeed for circle packing
            rng = seededRandom(lensSeed);
            attempts = 0;

            // Keep anchors, regenerate rings
            // Vary the number of rings per composition for layer variety
            // Use weighted distribution: favor 3-8 lenses, but allow 1-2 or 9-12
            const r = rng();
            let numRings;
            if (r < 0.10) {
                // 10% very sparse (1-2 lenses)
                numRings = Math.floor(rng() * 2) + 1;
            } else if (r < 0.75) {
                // 65% normal (3-8 lenses)
                numRings = Math.floor(rng() * 6) + 3;
            } else {
                // 25% dense (9-12 lenses)
                numRings = Math.floor(rng() * 4) + 9;
            }

            rings = [];
            for (let i = 0; i < numRings; i++) {
                step();
            }
        }

        // Get leg count for a leg type (single=1, double=2, curved=1)
        function getLegCount(legType) {
            if (legType === 'double') return 2;
            if (legType === 'none') return 0;
            return 1; // single, curved_lc, curved_cr, curved_lr, curved_adjacent
        }

        // Find adjacent (tangent) rings - returns index or -1
        function findAdjacentRing(ringIndex) {
            const ring = rings[ringIndex];
            const TANGENT_TOLERANCE = 3; // 3mm tolerance for tangency

            for (let i = 0; i < rings.length; i++) {
                if (i === ringIndex) continue;

                const other = rings[i];
                const dx = ring.x - other.x;
                const dy = ring.y - other.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const expectedDist = ring.radius + other.radius;

                // Check if rings are tangent (within tolerance)
                if (Math.abs(dist - expectedDist) < TANGENT_TOLERANCE) {
                    return i;
                }
            }
            return -1;
        }

        // Regenerate legs while keeping rings and anchors static
        function regenerateLegs() {
            if (rings.length === 0) return;

            // Generate new leg seed
            legSeed = Date.now();
            const legRng = seededRandom(legSeed);

            // First, set all rings to 'none' and clear adjacentRingIndex
            rings.forEach(ring => {
                ring.legType = 'none';
                ring.adjacentRingIndex = -1;
            });

            // Build legs up to max count
            let currentLegCount = 0;
            const availableIndices = rings.map((_, i) => i);

            // Shuffle available indices
            for (let i = availableIndices.length - 1; i > 0; i--) {
                const j = Math.floor(legRng() * (i + 1));
                [availableIndices[i], availableIndices[j]] = [availableIndices[j], availableIndices[i]];
            }

            // Assign legs until we hit the max count or run out of rings
            for (let i = 0; i < availableIndices.length && currentLegCount < MAX_LEG_COUNT; i++) {
                const ringIndex = availableIndices[i];
                let legType = assignLegType(legRng);

                // If curved_adjacent, check if there's an adjacent ring available
                if (legType === 'curved_adjacent') {
                    const adjacentIndex = findAdjacentRing(ringIndex);
                    if (adjacentIndex !== -1 && rings[adjacentIndex].legType === 'none') {
                        // Valid adjacent pair found
                        rings[ringIndex].adjacentRingIndex = adjacentIndex;
                    } else {
                        // No valid adjacent ring, fallback to regular curved leg
                        const fallbackTypes = ['curved_lc', 'curved_cr', 'curved_lr'];
                        legType = fallbackTypes[Math.floor(legRng() * fallbackTypes.length)];
                    }
                }

                const legCount = getLegCount(legType);

                // Check if adding this leg would exceed max
                if (currentLegCount + legCount <= MAX_LEG_COUNT) {
                    rings[ringIndex].legType = legType;
                    currentLegCount += legCount;
                } else if (currentLegCount < MAX_LEG_COUNT) {
                    // We have room for a single leg but not a double
                    // Force a single or curved leg
                    const singleLegTypes = ['single', 'curved_lc', 'curved_cr', 'curved_lr'];
                    rings[ringIndex].legType = singleLegTypes[Math.floor(legRng() * singleLegTypes.length)];
                    currentLegCount += 1;
                }
            }

            // Ensure at least one leg exists
            if (currentLegCount === 0 && rings.length > 0) {
                rings[0].legType = 'single';
            }

            draw();
        }

        // Cycle to next color palette
        function cyclePalette() {
            currentPaletteIndex = (currentPaletteIndex + 1) % PALETTE_ORDER.length;
            const paletteKey = PALETTE_ORDER[currentPaletteIndex];
            LENS_COLORS = COLOR_PALETTES[paletteKey].colors;

            // Reassign colors to existing lenses
            rings.forEach((ring, i) => {
                ring.color = LENS_COLORS[i % LENS_COLORS.length];
            });

            console.log(`Switched to palette: ${COLOR_PALETTES[paletteKey].name}`);
            updateInfo();
            draw();
        }

        function generate() {
            currentSeed = Date.now();
            lensSeed = Date.now();
            legSeed = Date.now();
            rng = seededRandom(currentSeed);
            attempts = 0;

            // Anchor geometry parameters matching main.js CONFIG
            // ANCHOR_BASE_RADIUS_MIN: 40mm, ANCHOR_BASE_RADIUS_MAX: 80mm
            // ANCHOR_ANGLE_JITTER: 0.3 rad (±17°)
            // ANCHOR_RADIUS_VARIATION: 20mm
            const baseRadius = rng() * 40 + 40; // 40-80mm range
            const jitter = 0.3;
            const variation = 20;

            // Generate 3 anchor points
            anchors = [];
            for (let i = 0; i < 3; i++) {
                const angle = (i / 3) * Math.PI * 2 + (rng() - 0.5) * jitter;
                const radius = baseRadius + (rng() - 0.5) * variation;
                anchors.push({
                    x: Math.cos(angle) * radius,
                    y: Math.sin(angle) * radius,
                    radius: ANCHOR_DIAMETER / 2  // Use actual anchor radius for tangency calculations
                });
            }

            // Generate rings (tangent solving)
            // Vary the number of rings per composition for layer variety
            // Use weighted distribution: favor 3-8 lenses, but allow 1-2 or 9-12
            const r = rng();
            let numRings;
            if (r < 0.10) {
                // 10% very sparse (1-2 lenses)
                numRings = Math.floor(rng() * 2) + 1;
            } else if (r < 0.75) {
                // 65% normal (3-8 lenses)
                numRings = Math.floor(rng() * 6) + 3;
            } else {
                // 25% dense (9-12 lenses)
                numRings = Math.floor(rng() * 4) + 9;
            }

            rings = [];
            for (let i = 0; i < numRings; i++) {
                step();
            }
        }

        // Export functions
        function exportJSON() {
            // Create JSON structure compatible with Python pipeline
            const jsonData = {
                layers: [{
                    frames: rings.map(ring => ({
                        radius: ring.radius,
                        position: {
                            x: ring.x,
                            y: ring.y
                        },
                        color: ring.color,
                        legType: ring.legType
                    }))
                }],
                anchors: anchors.map(anchor => ({
                    position: {
                        x: anchor.x,
                        y: anchor.y
                    },
                    radius: anchor.radius
                })),
                metadata: {
                    seed: currentSeed,
                    lensSeed: lensSeed,
                    legSeed: legSeed,
                    timestamp: new Date().toISOString()
                }
            };

            // Create and download JSON file
            const jsonString = JSON.stringify(jsonData, null, 2);
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `composition_${currentSeed}.json`;
            link.click();
            URL.revokeObjectURL(url);

            console.log('JSON exported:', jsonData);
        }

        function exportPNG() {
            // Create a temporary canvas with white background
            const exportCanvas = document.createElement('canvas');
            exportCanvas.width = canvas.width;
            exportCanvas.height = canvas.height;
            const exportCtx = exportCanvas.getContext('2d');

            // Fill with white background
            exportCtx.fillStyle = '#ffffff';
            exportCtx.fillRect(0, 0, exportCanvas.width, exportCanvas.height);

            // Draw the current canvas content on top
            exportCtx.drawImage(canvas, 0, 0);

            // Convert to PNG and download
            exportCanvas.toBlob((blob) => {
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `composition_${currentSeed}.png`;
                link.click();
                URL.revokeObjectURL(url);
            }, 'image/png');

            console.log('PNG exported');
        }

        function step() {
            // Try to add one ring
            const maxAttempts = 500;
            let placed = false;

            for (let attempt = 0; attempt < maxAttempts && !placed; attempt++) {
                attempts++;

                // Pick random anchor to be tangent to
                const anchor = anchors[Math.floor(rng() * anchors.length)];

                // Pick random radius with more variety
                // Use weighted distribution: favor medium sizes but allow extremes
                const r = rng();
                let radius;
                if (r < 0.15) {
                    // 15% small lenses (10-25mm)
                    radius = rng() * 15 + 10;
                } else if (r < 0.70) {
                    // 55% medium lenses (25-50mm)
                    radius = rng() * 25 + 25;
                } else if (r < 0.90) {
                    // 20% large lenses (50-75mm)
                    radius = rng() * 25 + 50;
                } else {
                    // 10% extra large lenses (75-100mm)
                    radius = rng() * 25 + 75;
                }

                // Pick second tangent target (another ring or anchor)
                const targets = [...rings, ...anchors.filter(a => a !== anchor)];

                if (targets.length === 0) {
                    // First ring - place tangent to anchor at random angle
                    const angle = rng() * Math.PI * 2;
                    const dist = anchor.radius + radius;
                    const x = anchor.x + Math.cos(angle) * dist;
                    const y = anchor.y + Math.sin(angle) * dist;

                    if (isValid({x, y, radius})) {
                        // Assign color from palette and leg type
                        const color = LENS_COLORS[rings.length % LENS_COLORS.length];
                        const legType = assignLegType(rng);
                        rings.push({x, y, radius, color, legType});
                        placed = true;
                    }
                } else {
                    // Solve for circle tangent to anchor AND another target
                    const target = targets[Math.floor(rng() * targets.length)];
                    const solution = solveTangentCircle(anchor, target, radius);

                    if (solution && isValid(solution)) {
                        // Assign color from palette and leg type
                        const color = LENS_COLORS[rings.length % LENS_COLORS.length];
                        const legType = assignLegType(rng);
                        solution.color = color;
                        solution.legType = legType;
                        rings.push(solution);
                        placed = true;
                    }
                }
            }

            draw();
            updateInfo();
        }

        function updateInfo() {
            document.getElementById('circle-count').textContent = rings.length;
            document.getElementById('attempts').textContent = attempts;
            document.getElementById('seed-display').textContent = currentSeed;
            const paletteKey = PALETTE_ORDER[currentPaletteIndex];
            document.getElementById('palette-name').textContent = COLOR_PALETTES[paletteKey].name;
        }

        function solveTangentCircle(c1, c2, radius) {
            // Solve for circle of given radius tangent to both c1 and c2
            // This is Apollonius' problem (CPP case - two circles, one point/radius)

            const dx = c2.x - c1.x;
            const dy = c2.y - c1.y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            // Distance from c1 center to new circle center
            const d1 = c1.radius + radius;
            // Distance from c2 center to new circle center
            const d2 = c2.radius + radius;

            // Check if solution is possible
            if (Math.abs(d1 - d2) > dist || d1 + d2 < dist) {
                return null;
            }

            // Using law of cosines to find angle
            const a = (d1 * d1 - d2 * d2 + dist * dist) / (2 * dist);
            const h = Math.sqrt(d1 * d1 - a * a);

            // Midpoint along line between centers
            const mx = c1.x + (dx / dist) * a;
            const my = c1.y + (dy / dist) * a;

            // Perpendicular offset
            const px = -dy / dist;
            const py = dx / dist;

            // Two solutions (pick one randomly)
            const sign = rng() < 0.5 ? 1 : -1;
            return {
                x: mx + px * h * sign,
                y: my + py * h * sign,
                radius: radius
            };
        }

        function isValid(circle) {
            // Check bounds
            if (Math.abs(circle.x) + circle.radius > BOUNDARY / 2) return false;
            if (Math.abs(circle.y) + circle.radius > BOUNDARY / 2) return false;

            // Check no overlap with existing rings
            for (const ring of rings) {
                const dx = circle.x - ring.x;
                const dy = circle.y - ring.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < circle.radius + ring.radius - 1) { // -1mm tolerance
                    return false;
                }
            }

            // Check no overlap with anchors (except tangency)
            for (const anchor of anchors) {
                const dx = circle.x - anchor.x;
                const dy = circle.y - anchor.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const expectedDist = circle.radius + anchor.radius;
                // Allow tangency (within 2mm) but not overlap
                if (dist < circle.radius + anchor.radius - 2 && Math.abs(dist - expectedDist) > 2) {
                    return false;
                }
            }

            return true;
        }

        function draw() {
            // Clear with white
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw legs (if enabled)
            const showLegs = document.getElementById('showLegs').checked;
            if (showLegs) {
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = LEG_THICKNESS * SCALE; // 1.2mm legs

                rings.forEach(ring => {
                    const cx = CENTER_X + ring.x * SCALE;
                    const cy = CENTER_Y + ring.y * SCALE;
                    const r = ring.radius * SCALE;
                    const legOffset = 0.6; // mm - half of frame outer ring width (1.2mm / 2)
                    const groundY = CENTER_Y + (BOUNDARY / 2) * SCALE;

                    switch(ring.legType) {
                        case 'none':
                            // No legs
                            break;

                        case 'single':
                            // Single straight leg from center bottom (offset inward)
                            const singleY = cy + (ring.radius - legOffset) * SCALE;
                            ctx.beginPath();
                            ctx.moveTo(cx, singleY);
                            ctx.lineTo(cx, groundY);
                            ctx.stroke();
                            break;

                        case 'double':
                            // Two straight legs from left and right (offset inward)
                            const doubleLeftX = cx - (ring.radius - legOffset) * SCALE;
                            const doubleRightX = cx + (ring.radius - legOffset) * SCALE;

                            ctx.beginPath();
                            ctx.moveTo(doubleLeftX, cy);
                            ctx.lineTo(doubleLeftX, groundY);
                            ctx.stroke();

                            ctx.beginPath();
                            ctx.moveTo(doubleRightX, cy);
                            ctx.lineTo(doubleRightX, groundY);
                            ctx.stroke();
                            break;

                        case 'curved_lc':
                            // Left-center U-shaped leg
                            // Vertical leg from left edge (offset inward by 0.6mm)
                            const leftEdgeX1 = cx - (ring.radius - legOffset) * SCALE;
                            const leftEdgeY1 = cy;

                            // Vertical leg from center bottom (offset inward by 0.6mm)
                            const centerBottomX1 = cx;
                            const centerBottomY1 = cy + (ring.radius - legOffset) * SCALE;

                            // Arc radius for the U-shape bottom
                            const arcRadius1 = (centerBottomX1 - leftEdgeX1) / 2;
                            const arcCenterX1 = leftEdgeX1 + arcRadius1;
                            const arcCenterY1 = groundY - arcRadius1;

                            // Only draw if arc center is below ring
                            if (arcCenterY1 > cy + r) {
                                // Draw left vertical
                                ctx.beginPath();
                                ctx.moveTo(leftEdgeX1, leftEdgeY1);
                                ctx.lineTo(leftEdgeX1, arcCenterY1);
                                ctx.stroke();

                                // Draw right vertical
                                ctx.beginPath();
                                ctx.moveTo(centerBottomX1, centerBottomY1);
                                ctx.lineTo(centerBottomX1, arcCenterY1);
                                ctx.stroke();

                                // Draw U-shaped arc at bottom
                                ctx.beginPath();
                                ctx.arc(arcCenterX1, arcCenterY1, arcRadius1, 0, Math.PI, false);
                                ctx.stroke();
                            }
                            break;

                        case 'curved_cr':
                            // Center-right U-shaped leg
                            // Vertical leg from center bottom (offset inward by 0.6mm)
                            const centerBottomX2 = cx;
                            const centerBottomY2 = cy + (ring.radius - legOffset) * SCALE;

                            // Vertical leg from right edge (offset inward by 0.6mm)
                            const rightEdgeX2 = cx + (ring.radius - legOffset) * SCALE;
                            const rightEdgeY2 = cy;

                            // Arc radius for the U-shape bottom
                            const arcRadius2 = (rightEdgeX2 - centerBottomX2) / 2;
                            const arcCenterX2 = centerBottomX2 + arcRadius2;
                            const arcCenterY2 = groundY - arcRadius2;

                            // Only draw if arc center is below ring
                            if (arcCenterY2 > cy + r) {
                                // Draw left vertical
                                ctx.beginPath();
                                ctx.moveTo(centerBottomX2, centerBottomY2);
                                ctx.lineTo(centerBottomX2, arcCenterY2);
                                ctx.stroke();

                                // Draw right vertical
                                ctx.beginPath();
                                ctx.moveTo(rightEdgeX2, rightEdgeY2);
                                ctx.lineTo(rightEdgeX2, arcCenterY2);
                                ctx.stroke();

                                // Draw U-shaped arc at bottom
                                ctx.beginPath();
                                ctx.arc(arcCenterX2, arcCenterY2, arcRadius2, 0, Math.PI, false);
                                ctx.stroke();
                            }
                            break;

                        case 'curved_lr':
                            // Left-right wide U-shaped leg
                            // Vertical leg from left edge (offset inward by 0.6mm)
                            const leftEdgeX3 = cx - (ring.radius - legOffset) * SCALE;
                            const leftEdgeY3 = cy;

                            // Vertical leg from right edge (offset inward by 0.6mm)
                            const rightEdgeX3 = cx + (ring.radius - legOffset) * SCALE;
                            const rightEdgeY3 = cy;

                            // Arc radius for the wide U-shape bottom
                            const arcRadius3 = (rightEdgeX3 - leftEdgeX3) / 2;
                            const arcCenterX3 = cx;
                            const arcCenterY3 = groundY - arcRadius3;

                            // Only draw if arc center is below ring
                            if (arcCenterY3 > cy + r) {
                                // Draw left vertical
                                ctx.beginPath();
                                ctx.moveTo(leftEdgeX3, leftEdgeY3);
                                ctx.lineTo(leftEdgeX3, arcCenterY3);
                                ctx.stroke();

                                // Draw right vertical
                                ctx.beginPath();
                                ctx.moveTo(rightEdgeX3, rightEdgeY3);
                                ctx.lineTo(rightEdgeX3, arcCenterY3);
                                ctx.stroke();

                                // Draw U-shaped arc at bottom
                                ctx.beginPath();
                                ctx.arc(arcCenterX3, arcCenterY3, arcRadius3, 0, Math.PI, false);
                                ctx.stroke();
                            }
                            break;

                        case 'curved_adjacent':
                            // Bridge leg connecting two adjacent (tangent) lenses
                            if (ring.adjacentRingIndex !== -1 && ring.adjacentRingIndex < rings.length) {
                                const adjacent = rings[ring.adjacentRingIndex];

                                // Calculate tangent point between the two circles
                                const dx = adjacent.x - ring.x;
                                const dy = adjacent.y - ring.y;
                                const dist = Math.sqrt(dx * dx + dy * dy);

                                // Tangent point is along the line connecting centers
                                // At distance r1 from center1
                                const tangentX = ring.x + (dx / dist) * ring.radius;
                                const tangentY = ring.y + (dy / dist) * ring.radius;

                                // Convert to canvas coordinates
                                const tangentCanvasX = CENTER_X + tangentX * SCALE;
                                const tangentCanvasY = CENTER_Y + tangentY * SCALE;

                                // Draw two vertical legs from the tangent point
                                const legSpacing = 3 * SCALE; // 3mm apart
                                const leg1X = tangentCanvasX - legSpacing / 2;
                                const leg2X = tangentCanvasX + legSpacing / 2;

                                // Arc radius for the bridge
                                const bridgeArcRadius = legSpacing / 2;
                                const bridgeArcCenterX = tangentCanvasX;
                                const bridgeArcCenterY = groundY - bridgeArcRadius;

                                // Only draw if arc center is below both rings
                                const ring1Bottom = cy + r;
                                const adjacent_cy = CENTER_Y + adjacent.y * SCALE;
                                const adjacent_r = adjacent.radius * SCALE;
                                const ring2Bottom = adjacent_cy + adjacent_r;

                                if (bridgeArcCenterY > ring1Bottom && bridgeArcCenterY > ring2Bottom) {
                                    // Draw left vertical leg
                                    ctx.beginPath();
                                    ctx.moveTo(leg1X, tangentCanvasY);
                                    ctx.lineTo(leg1X, bridgeArcCenterY);
                                    ctx.stroke();

                                    // Draw right vertical leg
                                    ctx.beginPath();
                                    ctx.moveTo(leg2X, tangentCanvasY);
                                    ctx.lineTo(leg2X, bridgeArcCenterY);
                                    ctx.stroke();

                                    // Draw U-shaped arc at bottom
                                    ctx.beginPath();
                                    ctx.arc(bridgeArcCenterX, bridgeArcCenterY, bridgeArcRadius, 0, Math.PI, false);
                                    ctx.stroke();
                                }
                            }
                            break;
                    }
                });
            }

            // Draw rings with frame structure
            const showColors = document.getElementById('showColors').checked;
            const stealthMode = document.getElementById('stealthMode').checked;
            const overlapZone = 0.5; // mm - suggested overlap for boolean union

            rings.forEach(ring => {
                const cx = CENTER_X + ring.x * SCALE;
                const cy = CENTER_Y + ring.y * SCALE;
                const r = ring.radius * SCALE;
                const frameWidth = 1.2; // mm - each part of frame
                const outerFrameRadius = r; // Outer edge
                const channelRadius = (ring.radius - frameWidth) * SCALE; // Channel ledge
                const innerRadius = (ring.radius - LENS_THICKNESS) * SCALE; // Inner clear area
                const overlapRadius = (ring.radius + overlapZone) * SCALE; // Overlap zone

                if (stealthMode) {
                    // Stealth mode - grayscale lenses, black everything else
                    // Fill inner area with grayscale
                    const grayValue = Math.floor(128 + Math.random() * 64); // Random gray 128-192
                    ctx.fillStyle = `rgb(${grayValue}, ${grayValue}, ${grayValue})`;
                    ctx.beginPath();
                    ctx.arc(cx, cy, innerRadius, 0, Math.PI * 2);
                    ctx.fill();

                    // Draw outer frame ring (black)
                    ctx.fillStyle = '#000000';
                    ctx.beginPath();
                    ctx.arc(cx, cy, outerFrameRadius, 0, Math.PI * 2);
                    ctx.arc(cx, cy, channelRadius, 0, Math.PI * 2, true);
                    ctx.fill();

                    // Draw channel ring (black instead of red)
                    ctx.fillStyle = '#000000';
                    ctx.beginPath();
                    ctx.arc(cx, cy, channelRadius, 0, Math.PI * 2);
                    ctx.arc(cx, cy, innerRadius, 0, Math.PI * 2, true);
                    ctx.fill();
                } else if (showColors) {
                    // Fill inner area with lens color
                    ctx.fillStyle = ring.color;
                    ctx.beginPath();
                    ctx.arc(cx, cy, innerRadius, 0, Math.PI * 2);
                    ctx.fill();

                    // Draw outer frame ring (black) - from outer edge to channel
                    ctx.fillStyle = '#000000';
                    ctx.beginPath();
                    ctx.arc(cx, cy, outerFrameRadius, 0, Math.PI * 2);
                    ctx.arc(cx, cy, channelRadius, 0, Math.PI * 2, true); // Counter-clockwise for hole
                    ctx.fill();

                    // Draw channel ring (black instead of red) - from channel to inner
                    ctx.fillStyle = '#000000';
                    ctx.beginPath();
                    ctx.arc(cx, cy, channelRadius, 0, Math.PI * 2);
                    ctx.arc(cx, cy, innerRadius, 0, Math.PI * 2, true); // Counter-clockwise for hole
                    ctx.fill();
                } else {
                    // Monochrome mode - draw frame structure in greyscale
                    // Outer frame ring (black)
                    ctx.fillStyle = '#000000';
                    ctx.beginPath();
                    ctx.arc(cx, cy, outerFrameRadius, 0, Math.PI * 2);
                    ctx.arc(cx, cy, channelRadius, 0, Math.PI * 2, true);
                    ctx.fill();

                    // Channel ring (red)
                    ctx.fillStyle = '#ff4444';
                    ctx.beginPath();
                    ctx.arc(cx, cy, channelRadius, 0, Math.PI * 2);
                    ctx.arc(cx, cy, innerRadius, 0, Math.PI * 2, true);
                    ctx.fill();

                    // Outline for visibility
                    ctx.strokeStyle = '#00ff00';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.arc(cx, cy, outerFrameRadius, 0, Math.PI * 2);
                    ctx.stroke();
                }

                // Highlight selected lens
                if (selectedLens === ring) {
                    ctx.strokeStyle = '#ff00ff'; // Magenta highlight
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(cx, cy, outerFrameRadius + 2, 0, Math.PI * 2);
                    ctx.stroke();
                }
            });

            // Draw anchor points (on top) - 6.36mm circle with 2.8mm square hole
            anchors.forEach((anchor, i) => {
                const x = CENTER_X + anchor.x * SCALE;
                const y = CENTER_Y + anchor.y * SCALE;
                const outerRadius = (ANCHOR_DIAMETER / 2) * SCALE;
                const holeSize = ANCHOR_HOLE_SIZE * SCALE;
                const overlapZone = 0.5; // mm - suggested overlap for boolean union

                // Draw outer circle (black)
                ctx.fillStyle = '#000000';
                ctx.beginPath();
                ctx.arc(x, y, outerRadius, 0, Math.PI * 2);
                ctx.fill();

                // Cut out square hole in center
                ctx.fillStyle = stealthMode ? '#000000' : '#ffffff';
                ctx.fillRect(
                    x - holeSize / 2,
                    y - holeSize / 2,
                    holeSize,
                    holeSize
                );

                // Stroke square hole for visibility
                ctx.strokeStyle = '#666666';
                ctx.lineWidth = 0.5;
                ctx.strokeRect(
                    x - holeSize / 2,
                    y - holeSize / 2,
                    holeSize,
                    holeSize
                );
            });
        }

        // Initial generation
        generate();
        updateInfo();

        // Mouse interaction for dragging anchors
        function getMousePos(e) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: (e.clientX - rect.left - CENTER_X) / SCALE,
                y: (e.clientY - rect.top - CENTER_Y) / SCALE
            };
        }

        function findAnchorAtPoint(x, y) {
            const clickRadius = 10; // pixels
            for (let anchor of anchors) {
                const dx = (x - anchor.x) * SCALE;
                const dy = (y - anchor.y) * SCALE;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < clickRadius) {
                    return anchor;
                }
            }
            return null;
        }

        function findLensAtPoint(x, y) {
            // Check if click is inside any lens
            for (let ring of rings) {
                const dx = x - ring.x;
                const dy = y - ring.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < ring.radius) {
                    return ring;
                }
            }
            return null;
        }

        canvas.addEventListener('mousedown', (e) => {
            const pos = getMousePos(e);

            // Check for anchor drag first (higher priority)
            draggedAnchor = findAnchorAtPoint(pos.x, pos.y);
            if (draggedAnchor) {
                isDragging = true;
                canvas.style.cursor = 'grabbing';
                selectedLens = null; // Deselect lens when dragging anchor
            } else {
                // Check for lens selection
                selectedLens = findLensAtPoint(pos.x, pos.y);
                if (selectedLens) {
                    draw(); // Redraw to show selection
                }
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            const pos = getMousePos(e);

            if (isDragging && draggedAnchor) {
                // Update anchor position
                draggedAnchor.x = pos.x;
                draggedAnchor.y = pos.y;

                // Regenerate rings with new anchor positions
                rings = [];
                attempts = 0;
                rng = seededRandom(currentSeed);
                for (let i = 0; i < 10; i++) {
                    step();
                }
            } else {
                // Update cursor based on hover
                const hoverAnchor = findAnchorAtPoint(pos.x, pos.y);
                canvas.style.cursor = hoverAnchor ? 'grab' : 'default';
            }
        });

        canvas.addEventListener('mouseup', () => {
            isDragging = false;
            draggedAnchor = null;
            canvas.style.cursor = 'default';
        });

        canvas.addEventListener('mouseleave', () => {
            isDragging = false;
            draggedAnchor = null;
            canvas.style.cursor = 'default';
        });

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                e.preventDefault();
                generate();
            } else if (e.code === 'Enter') {
                e.preventDefault();
                step();
            } else if (e.code === 'KeyK') {
                // K for Knife - remove legs from selected lens
                e.preventDefault();
                if (selectedLens) {
                    selectedLens.legType = 'none';
                    console.log('Removed legs from selected lens');
                    draw();
                }
            } else if (e.code === 'KeyR') {
                // R for Re-roll - cycle to next leg type
                e.preventDefault();
                if (selectedLens) {
                    const legTypes = ['none', 'single', 'double', 'curved_lc', 'curved_cr', 'curved_lr', 'curved_adjacent'];
                    const currentIndex = legTypes.indexOf(selectedLens.legType);
                    const nextIndex = (currentIndex + 1) % legTypes.length;
                    selectedLens.legType = legTypes[nextIndex];
                    console.log(`Changed leg type to: ${selectedLens.legType}`);
                    draw();
                }
            } else if (e.code === 'KeyD') {
                // D for Delete - remove selected lens
                e.preventDefault();
                if (selectedLens) {
                    rings = rings.filter(ring => ring !== selectedLens);
                    selectedLens = null;
                    console.log('Deleted lens');
                    updateInfo();
                    draw();
                }
            } else if (e.code === 'KeyA') {
                // A for Add - add new tangent lens
                e.preventDefault();

                // Pick random target (anchor or existing lens)
                const allTargets = [...anchors, ...rings];
                if (allTargets.length === 0) return;

                const target = allTargets[Math.floor(Math.random() * allTargets.length)];

                // Random radius in medium range (20-40mm)
                const newRadius = Math.random() * 20 + 20;

                // Try to find tangent position
                const maxAttempts = 100;
                for (let attempt = 0; attempt < maxAttempts; attempt++) {
                    // Pick second target for tangency (prefer anchors/rings, not the same as first)
                    let secondTarget = target;
                    if (allTargets.length > 1) {
                        const otherTargets = allTargets.filter(t => t !== target);
                        secondTarget = otherTargets[Math.floor(Math.random() * otherTargets.length)];
                    }

                    // Calculate tangent circle
                    const newCircle = solveTangentCircle(target, secondTarget, newRadius);

                    if (newCircle && isValid(newCircle)) {
                        // Success! Add the new lens
                        newCircle.color = LENS_COLORS[rings.length % LENS_COLORS.length];
                        newCircle.legType = 'none'; // Start with no legs
                        rings.push(newCircle);
                        selectedLens = newCircle;
                        console.log('Added new lens');
                        updateInfo();
                        draw();
                        break;
                    }
                }
            } else if (e.code === 'KeyN') {
                // N for regeNerate lenses
                e.preventDefault();
                regenerateLenses();
            } else if (e.code === 'KeyM') {
                // M for reMake legs
                e.preventDefault();
                regenerateLegs();
            } else if (e.code === 'KeyP') {
                // P for Palette - cycle color palette
                e.preventDefault();
                cyclePalette();
            } else if (e.code === 'KeyL') {
                e.preventDefault();
                document.getElementById('showLegs').checked = !document.getElementById('showLegs').checked;
                draw();
            } else if (e.code === 'KeyC') {
                e.preventDefault();
                document.getElementById('showColors').checked = !document.getElementById('showColors').checked;
                draw();
            }
        });
    </script>
</body>
</html>
